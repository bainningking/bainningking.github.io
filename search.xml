<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pandas如何对每行进行操作（apply函数用法）</title>
    <url>/2022/05/11/20220511_pandas%E5%A6%82%E4%BD%95%E5%AF%B9%E6%AF%8F%E8%A1%8C%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%88apply%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>在对dataframe做处理时，有个需求需要<strong>对dataframe的每一行的不同列进行操作</strong>，如何做到呢？</p>
<p>经过搜索，发现pandas内部的apply函数可以完美解决这个问题，但是网上的示例不够清晰，特别是每一行作为参数要写吗？如果要用到外部参数又该怎么写？</p>
<p>在此记录下学习过程，希望对看到这篇博客的你也有帮助。</p>
<h1 id="apply函数的使用"><a href="#apply函数的使用" class="headerlink" title="apply函数的使用"></a>apply函数的使用</h1><h2 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h2><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220511194028441.png" alt="image-20220511194028441"></p>
<p>经过查看引用，发现apply函数可以对dataframe和Series类型使用，此处我们查看dataframe的apply：</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply</span>(<span class="params">self, func, axis=<span class="number">0</span>, raw=<span class="literal">False</span>, result_type=<span class="literal">None</span>, args=(<span class="params"></span>), **kwds</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Apply a function along an axis of the DataFrame.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Objects passed to the function are Series objects whose index is</span></span><br><span class="line"><span class="string">    either the DataFrame&#x27;s index (``axis=0``) or the DataFrame&#x27;s columns</span></span><br><span class="line"><span class="string">    (``axis=1``). By default (``result_type=None``), the final return type</span></span><br><span class="line"><span class="string">    is inferred from the return type of the applied function. Otherwise,</span></span><br><span class="line"><span class="string">    it depends on the `result_type` argument.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过函数介绍，我们知道了以下信息：</p>
<ol>
<li>apply会将自定义的func函数应用在dataframe的每列或者每行上面。</li>
<li>func接收的是每列或者每行转换成的一个Series对象，此对象的索引是行索引（对df每列操作时）或者列索引（对每行操作时），<strong>axis&#x3D;0代表对每行操作，axis&#x3D;1代表对每列操作</strong>。</li>
<li>apply函数的返回仍是一个Series对象，索引不变，值取决于自定义函数func的返回类型。如果定义了result_type参数，则返回类型根据此参数执行变化。</li>
</ol>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>由于我要解决的问题是对每行进行带参数的操作，经过搜索和尝试，最终应用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个示例dataframe，用于测试</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame([[<span class="number">4</span>, <span class="number">9</span>]] * <span class="number">3</span>, columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   A  B</span><br><span class="line"><span class="number">0</span>  <span class="number">4</span>  <span class="number">9</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">9</span></span><br><span class="line"><span class="number">2</span>  <span class="number">4</span>  <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.首先定义一个函数，此函数要对df的每行进行操作</span></span><br><span class="line"><span class="comment"># 1.需要重点说明的就是fun1的第一个形参就是df的每一行，可以把此行当做字典，键就是列名；</span></span><br><span class="line"><span class="comment"># 2.在此之后的形参才是apply函数中args的参数，即我们要传入的外部参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>(<span class="params">row, num</span>):  <span class="comment"># row是dataframe的每一行，num是外部要用的参数</span></span><br><span class="line">    <span class="keyword">return</span> row[<span class="string">&#x27;A&#x27;</span>] + row[<span class="string">&#x27;B&#x27;</span>] &gt; num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.因为是对每行操作，所以axis=1,fun1的首个参数为row,如果axis=0,row用column表示更易理解</span></span><br><span class="line"><span class="comment"># 1.fun1的参数在args里面传，并且不用传递row，这个是默认作为第一个参数的</span></span><br><span class="line"><span class="comment"># 2.args必须是个元组，如果你的参数只有一个，那么必须写出如下形式(10,)，因为(10)不是元组，而是int</span></span><br><span class="line"><span class="comment"># 3.如果传多个参数则不用在最后写逗号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = df.apply(fun1, args=(<span class="number">10</span>,), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们将结果打印，看下apply返回的值</span></span><br><span class="line"><span class="comment"># 可见是类似Series的数据，它的索引与原始df相同，值与fun1函数的返回相同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line"><span class="number">0</span>    <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.一般对于<strong>无需传递外部参数</strong>的<strong>一维可迭代对象</strong>（Series,list），一般使用map(lambda x: 函数体)的形式就可以对单一元素对象进行操作了；</p>
<p>2.对于dataframe这一类二维表，需要对其中的每个单一维度（每行或者每列）进行操作，apply函数可以说是瑞士军刀般的解决方案了。</p>
<p>3.在实际使用过程中其实我还想用当前行与其上一行进行逻辑操作，但是没找到什么好的方法，如有思路，还请指教。</p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>python如何读取大文件</title>
    <url>/2022/05/16/20220516_python%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220517162535014.png" alt="image-20220517162535014"></p>
<p>在一次面试过程中，主考官提出了问题：如何使用python读取大文件</p>
<p>而我一般知道：</p>
<p>1.一般读取、操作文件都是整体读取到内存中，所以在内存不够大的时候，读取大文件会造成非常耗时+内存溢出的问题</p>
<p>2.我在工作场景中一般读取文件都是使用pd.read_csv()这个pandas的命令，因此只回答了这个方法内置了chunksize参数,可以用于按照指定行数读取文件（返回一个可迭代对象，每次迭代一个分块），每个分块都是dataframe，且每个dataframe的行数是chunksize。</p>
<p>因此，今天专门去搜索了相关的资料，总结如下。</p>
<h1 id="python读取大文件最常用的两种方法"><a href="#python读取大文件最常用的两种方法" class="headerlink" title="python读取大文件最常用的两种方法"></a>python读取大文件最常用的两种方法</h1><p>通常面对的大文件有两种形式：</p>
<ul>
<li><p>多行大文件，一般里面存放的是<strong>字符串（普通文本）</strong></p>
</li>
<li><p>单行大文件，一般里面存放的是<strong>字节串（二进制流）</strong></p>
</li>
</ul>
<p>因此，在经过面向搜索引擎编程后，总结了最有针对性+最优+最简的两种方法分别针对两种情况：</p>
<h2 id="针对多行大文件"><a href="#针对多行大文件" class="headerlink" title="针对多行大文件"></a>针对多行大文件</h2><span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220517164754046.png" alt="image-20220517164754046"></p>
<p>使用open的基础方法：open打开的是一个按行迭代的可迭代对象，通过对其进行遍历，即可一行一行的读取文件，避免一次占用较大内存，底层内置了io缓存和内存的管理，无需使用者关心。</p>
<p>with句柄作为上下文管理器，负责打开和关闭文件（包括在内部块中引发异常时）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for line in f 会将文件对象 f 视为一个可迭代的数据类型,自动使用 IO 缓存和内存管理</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filename&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        do_something(line)</span><br></pre></td></tr></table></figure>

<h2 id="针对单行大文件"><a href="#针对单行大文件" class="headerlink" title="针对单行大文件"></a>针对单行大文件</h2><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220517164819877.png" alt="image-20220517164819877"></p>
<p>上面的open方法解决不了的一个问题是：当大文件只有一行时该怎么办</p>
<p>因此，此方法借助文件对象的read(size&#x3D;1024*8)方法，按数据的大小进行分块读取，size的单位是比特：bytes</p>
<p>借助patial方法和iter方法更pythonic的实现这个功能：</p>
<ul>
<li>functools.partial(io.read,size)用来创建一个每次被调用时从文件中读取固定数目字节的<strong>可调用对象</strong>,他接收两个参数，一个是函数，一个是函数参数，返回的是每次调用此函数的返回对象。因此，一般使用返回迭代器的函数+参数作为partial的函数输入。</li>
<li>iter()函数有一个鲜为人知的特性就是，如果你给它传递一个可调用对象和一个标记值，它会创建一个迭代器。这个迭代器会一直调用传入的可调用对象直到它返回标记值为止，这时候迭代终止。在下面的例子中，iter循环将不断返回 fp.read(block_size) 调用结果，直到其为 ‘’ 时终止，标记值b’’就是当到达文件结尾时的返回值。</li>
<li>PS.如果总文件大小不是块大小的整数倍的话，最后一个返回元素的字节数会比期望值少。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成器函数：分块读取文件内容，使用 iter+partial 函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chunked_file_reader</span>(<span class="params">file, block_size=<span class="number">1024</span> * <span class="number">8</span></span>):</span><br><span class="line">    records = <span class="built_in">iter</span>(partial(file.read, block_size), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> records:</span><br><span class="line">        <span class="keyword">yield</span> chunk</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 分数据块读取文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filename&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> chunked_file_reader(f):</span><br><span class="line">        do_something(chunk)</span><br></pre></td></tr></table></figure>

<h1 id="知识补充："><a href="#知识补充：" class="headerlink" title="知识补充："></a>知识补充：</h1><h2 id="partial函数"><a href="#partial函数" class="headerlink" title="partial函数"></a>partial函数</h2><p>如果需要减少某个函数的参数个数，你可以使用 <code>functools.partial()</code> 。 <code>partial()</code> 函数允许你给一个或多个参数设置固定的值，减少接下来被调用时的参数个数。 </p>
<p><code>partial()</code>会固定某些参数并返回一个新的callable对象。这个新的callable接受未赋值的参数， 然后跟之前已经赋值过的参数合并起来，最后将所有参数传递给原始函数。</p>
<p>partial的内部机制和装饰器一样利用了函数式编程的闭包特性。简而言之，partial作为一个函数式编程中的高阶函数，其功能就是为某个已经存在的函数对象提供了一种简洁的绑定函数参数的方式。对于关键字参数，相当于提供默认值，对位置参数相当于冻结参数。</p>
<p>重要的是，这种参数绑定，不是在函数定义阶段（比如默认值参数），而是借助外部工具partial来进行参数的绑定，返回一个参数缩减的特化版本，这个绑定过程可以发生在编写代码的阶段（简单的得到一个特化函数），甚至可以发生在运行时，通过配置文件或者交互输入解析待绑定的参数，来动态的生成特定功能的函数。</p>
<p>PS. <code>partial</code>做到了开放封闭原则：<strong>对外开放，对内（修改）封闭</strong></p>
<p>参考：<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p08_make_callable_with_fewer_arguments.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p08_make_callable_with_fewer_arguments.html</a></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/47124891">https://zhuanlan.zhihu.com/p/47124891</a></p>
<h2 id="iter函数"><a href="#iter函数" class="headerlink" title="iter函数"></a>iter函数</h2><p>iter()函数有两种用法，一种是传一个参数，一种是传两个参数。结果都是返回一个iterator对象。</p>
<p>所谓的iterator对象，就是有个next()方法的对象。next方法的惯例或约定（convention）是，每执行一次就返回下一个值（因此它要自己记录状态，通常是在iterator对象上记录），直到没有值的时候raiseStopIteration。</p>
<p>传1个参数：参数collection应是一个可迭代的集合对象，支持迭代协议(即定义有__iter__()函数)，或者支持序列访问协议（即定义有getitem()函数），否则会返回TypeError异常。</p>
<p>传2个参数：当第二个参数sentinel出现时，参数callable应是一个可调用对象(实例)，即定义了__call__()方法，当枚举到的值等于哨兵时，就会抛出StopIteration异常。</p>
<p>参考：<a href="https://blog.csdn.net/sxingming/article/details/51479039">https://blog.csdn.net/sxingming/article/details/51479039</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在搜索资料的过程中，发现了读取大文件还有很多其他写法，但是归根到底的就这两类情况，其他的都是这两类的变种。</p>
<p>如果有其他方法，还请大神在评论区指出，不胜感激涕零。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>面试问题</tag>
        <tag>大文件</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的GIL是什么</title>
    <url>/2022/05/18/20220518_Python%E4%B8%AD%E7%9A%84GIL%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<hr>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519145508151.png" alt="image-20220519145508151"></p>
<p>一直听说GIL是python的弱点，工作过程中也只了解个皮毛，偶然看到一篇外文讲的很好，因此翻译搬运到这里，如有不足，欢迎提出。</p>
<h1 id="什么是Python的全局解释锁（Global-Interpreter-Lock-GIL-）"><a href="#什么是Python的全局解释锁（Global-Interpreter-Lock-GIL-）" class="headerlink" title="什么是Python的全局解释锁（Global Interpreter Lock (GIL)）"></a>什么是Python的全局解释锁（Global Interpreter Lock (GIL)）</h1><p>Python全局解释锁，或者叫 <a href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL</a>，简单来说，是一个互斥锁（或锁）——<strong>它只允许单个<a href="https://realpython.com/intro-to-python-threading/">线程</a>持有对 Python 解释器的控制权。</strong></p>
<p>这意味着在任何时间点都只能有一个线程处于执行状态。执行单线程程序的开发人员看不到 GIL 的影响，但它可能成为 CPU 密集型和多线程代码的性能瓶颈。</p>
<p>由于即使在具有多个 CPU 内核的多线程架构中，GIL在每个时间点也只允许一个线程执行任务，因此 GIL 已成为 Python 长期“受人诟病”的特性。</p>
<p><strong>在本文中，您将了解 GIL 如何影响 Python 程序的性能，以及如何减轻它可能对代码产生的影响。</strong></p>
<h1 id="GIL-为-Python-解决了什么问题？"><a href="#GIL-为-Python-解决了什么问题？" class="headerlink" title="GIL 为 Python 解决了什么问题？"></a>GIL 为 Python 解决了什么问题？</h1><span id="more"></span>

<p>Python使用<strong>引用计数机制</strong>进行内存管理。这意味着所有在Python中创建的对象都具有一个引用计数变量，该变量用来表示该对象被引用的数量。当此计数达到零时，说明没有变量和参数引用此对象，则释放该对象占据的内存。</p>
<p>让我们看一个简短的代码示例，以说明引用计数机制的工作方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，空列表对象[]的引用计数为3。列表对象被a，b和传递给sys.getrefcount()的参数引用。</p>
<p>回到GIL上：</p>
<p>python需要解决的问题是：在两个线程同时想要改变某对象的引用计数值的情况下，如何正确的进行处理以保证程序运行正常。假设没有正确的处理这种情况，它可能会导致内存泄漏问题（对象占用的内存永远不会释放），或者更糟糕的是，在对该对象的引用仍然存在时错误地释放内存。这可能会导致 Python 程序崩溃或其他莫名其妙的错误。</p>
<p>这个引用计数变量可以通过向所有线程共享的数据结构（对象）添加<strong>锁</strong>来保持安全，这样它们就不会被不一致地修改。</p>
<p>但是为每个对象或对象组添加一个锁意味着将存在多个锁，这可能会导致另一个问题——死锁（死锁只有在存在多个锁时才会发生）。另一个副作用是由于不同线程重复获取和释放锁会导致性能下降。（解决锁竞争需要通过机制协调，这个过程会增加性能开销）</p>
<p>GIL 是Python解释器本身自带的锁机制，它添加了一条规则，即对任何 Python 字节码的执行都需要获取全局解释器锁（GIL）。好处是这可以防止死锁（因为只有一个锁）并且不会引入太多的性能开销。坏处是它有效地使任何受 CPU 限制的 Python 程序成为单线程的（多线程无法利用多核CPU并行计算的优势，仍只能每个时间点只利用一个CPU）。</p>
<p>虽然 Ruby 等其他语言的解释器也使用了GIL，但并不是说线程安全的问题只能用GIL解决。某些语言通过使用引用计数以外的方法（例如垃圾收集）来避免 GIL 对线程内存安全管理的要求。</p>
<p>换句话说，这通常意味着不使用GIL的语言必须通过添加其他性能提升功能（如 JIT 编译器）来弥补 GIL 单线程性能优势的损失。</p>
<p>（译者：也就是说GIL是把双刃剑：对于单线程程序会很快，但是损失了多线程并行计算的能力；不使用GIL虽然解决了多线程并行计算的问题，但是会增加单线程运行时的性能开销。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519145105949.png" alt="image-20220519145105949"></p>
<h1 id="为什么Python仍然选择-GIL-作为解决方案呢？"><a href="#为什么Python仍然选择-GIL-作为解决方案呢？" class="headerlink" title="为什么Python仍然选择 GIL 作为解决方案呢？"></a>为什么Python仍然选择 GIL 作为解决方案呢？</h1><p>那么，为什么 Python 选择了一种看似如此不便利的方法呢？这对开发 Python 语言的人员来说算是做出了一个错误的决定吗？</p>
<p>嗯，用<a href="https://youtu.be/KVKufdTphKs?t=12m11s">Larry Hastings 的话来说，</a> 设计使用 GIL 正是是让 Python 像今天这样流行的原因之一。</p>
<p>Python 在操作系统还没有线程这个概念的时候就存在了。 语言被发明的初衷就是要易于使用，以便可以更快的进行开发工作，这一点也让越来越多的开发人员开始使用它。</p>
<!--译者注：这个描述是有问题的，第一个线程描述在1967年的MVT中就被提到了，而Python是在1990年被荷兰数学与计算机科学家 吉多·范罗苏姆 设计发明的-->

<p>在用C语言开发Python的过程中，开发人员为现有的 C 语言库编写了许多扩展，因为这些扩展库的特性在 Python 中是必需的。为了防止不一致的更改，这些 C 扩展需要使用 GIL 提供的线程安全的内存管理机制来保证。</p>
<p>GIL 易于实现，并且很容易添加到 Python 中。它提升了单线程程序的运行性能——因为只需要管理一个锁。</p>
<p>GIL使得非线程安全的 C 库变得更容易集成。而正是这些对 C 库的扩展（使用了GIL）成为 Python 被不同社区欣然采用的原因之一。</p>
<p>因此可以看出，GIL 是CPython开发人员针对在 Python 早期面临的难题的实用解决方案。</p>
<h1 id="对-Python-多线程程序的影响"><a href="#对-Python-多线程程序的影响" class="headerlink" title="对 Python 多线程程序的影响"></a>对 Python 多线程程序的影响</h1><p>在你查看一个典型的 Python 程序或任何计算机程序时，一般情况下，性能瓶颈主要体现在两个方面：</p>
<ul>
<li>CPU密集型程序——受 CPU 能力限制</li>
<li>IO密集型程序——受 I&#x2F;O 能力限制</li>
</ul>
<p>CPU 密集型程序是那些将 CPU 推到使用极限的程序（即频繁使用CPU的程序）。包括进行数学计算的程序，如矩阵乘法、搜索、图像处理等。</p>
<p>I&#x2F;O 密集型程序是那些需要花费时间来等待用户、文件、数据库、网络等输入输出（Input&#x2F;Output）的程序。I&#x2F;O 密集型程序有时必须等待大量时间，直到它们从数据来源获得他们需要的东西，因为数据来源可能需要在输入&#x2F;输出准备好之前进行自己的处理，例如，用户正在考虑输入什么内容到命令提示符，或数据库正在查询数据的过程。</p>
<p>让我们来看一个简单的 CPU 密集型程序——执行倒计时任务：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># single_threaded.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">countdown(COUNT)</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Time taken in seconds -&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure>

<p>在我的 4 核CPU系统上运行此代码会得到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python single_threaded.py</span></span><br><span class="line">Time taken in seconds - 6.20024037361145</span><br></pre></td></tr></table></figure>

<p>现在我稍微修改下代码，这次使用两个并行线程来执行相同的倒计时任务：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multi_threaded.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=countdown, args=(COUNT//<span class="number">2</span>,))</span><br><span class="line">t2 = Thread(target=countdown, args=(COUNT//<span class="number">2</span>,))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Time taken in seconds -&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure>

<p>当我再次运行它时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python multi_threaded.py</span></span><br><span class="line">Time taken in seconds - 6.924342632293701</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519145410239.png" alt="image-20220519145410239"></p>
<p>如您所见，两个版本的完成时间几乎相同。在多线程版本中，GIL 阻止了CPU密集型程序的线程并行执行。</p>
<p>GIL 对 I&#x2F;O 密集型的多线程程序性能没有太大影响，因为在线程等待 I&#x2F;O 时，锁是在线程之间共享的。</p>
<p>当程序是完全的 CPU 密集型程序时，比如处理图像的程序，假如使用Python的多线程去做，不仅程序会因为GIL而变成单线程，而且还会看到执行时间增加了，如上面的示例所示。</p>
<p>这是因为与完全单线程的情况相比，多线程增加了锁的获取和释放的步骤，造成了更多的性能开销的结果。</p>
<h1 id="为什么-GIL-还没有被移除？"><a href="#为什么-GIL-还没有被移除？" class="headerlink" title="为什么 GIL 还没有被移除？"></a>为什么 GIL 还没有被移除？</h1><p>Python 的开发人员收到了很多关于GIL的抱怨，但是像 Python 这样流行的语言如果删除了 GIL机制 ，这么大的变更如果向后兼容出现了问题，这是不能接受的。</p>
<p>GIL 当然是可以被删除的，过去开发人员和研究人员已经多次这样尝试，但所有这些尝试都破坏了现有的 C 扩展，因为这些扩展严重依赖于 GIL 提供的解决方案。</p>
<p>当然，还有其他解决方案可以替代GIL解决C扩展面临的问题，但其中一些会降低单线程和多线程 I&#x2F;O 密集型程序的性能，另外一些则太难了。毕竟，您不希望现有的 Python 程序更新新版本python后运行速度变慢，对吧？</p>
<p>Python 的创始人和 BDFL（Benevolent Dictator For Life，<strong>终身仁慈独裁者</strong>），Guido van Rossum，于 2007 年 9 月在他的文章<a href="https://www.artima.com/weblogs/viewpost.jsp?thread=214235">“移除 GIL 并不容易”</a>中对社区做出了回答：</p>
<blockquote>
<p>“只有在单线程程序（以及多线程 I&#x2F;O 密集型的程序）的性能不降低的情况下，我才会同意在 Python3 中打补丁（解决GIL造成的问题）”</p>
</blockquote>
<p>从那以后所做的任何试图解决GIL的尝试都没有满足这一条件。</p>
<h1 id="为什么GIL没有在-Python-3-中被移除？"><a href="#为什么GIL没有在-Python-3-中被移除？" class="headerlink" title="为什么GIL没有在 Python 3 中被移除？"></a>为什么GIL没有在 Python 3 中被移除？</h1><p>Python 3 （相较Python 2）确实从头开始增加了很多特性，并且在这个过程中，也确实破坏了一些现有的 C 扩展——这些扩展需要更新和移植才能与 Python 3 一起使用。这就是为什么Python 3 的早期版本被社区采用速度较慢的原因。</p>
<p>但是为什么 GIL 没有在这个过程中被移除呢？</p>
<p>与 Python 2 相比，删除 GIL 后在单线程性能方面会使 Python 3 变慢，您可以想象这会导致什么结果。目前还没有解决方案能替代 GIL 在单线程性能上的优势。所以结果 Python 3 仍然保有 GIL。</p>
<p>但 Python 3 确实为现有的 GIL 带来了重大改进——</p>
<p>我们上面讨论的 GIL 对多线程的影响，仅仅是对“纯粹的CPU密集型”和“纯粹的I&#x2F;O 密集型”的多线程程序的影响，但是实际的程序往往没那么“纯粹”，那么GIL 对于某些线程是CPU密集而某些线程是IO密集的多线程程序的影响又是怎么样的呢？</p>
<p>在这样的程序中，可以想象，Python 的 GIL 会饿死 I&#x2F;O 密集型线程，因为它们得不到从 CPU 密集型线程获取 GIL 的机会。</p>
<p>这是因为 Python 内置的一种机制，它会强制线程在连续使用<strong>固定间隔后</strong>释放 GIL ，如果没有其他线程获得 GIL，同一个线程可以继续使用它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The interval is set to 100 instructions:(这个间隔被设置为100个指令执行时间)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getcheckinterval()</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>这种机制的问题在于，大多数情况下， CPU 密集型的线程会在其他线程获取 GIL 之前重新获取 GIL。这种机制 David Beazley 做了相关研究，可以在<a href="http://www.dabeaz.com/blog/2010/01/python-gil-visualized.html">此处</a>找到可视化的内容。</p>
<p>这个问题在 2009 年的 Python 3.2 中由 Antoine Pitrou 修复，他<a href="https://mail.python.org/pipermail/python-dev/2009-October/093321.html">添加了一种机制</a>，可以查看其他线程被丢弃的 GIL 获取请求的数量，并且不允许当前线程在其他线程有机会运行之前重新获取 GIL。</p>
<h1 id="如何处理-Python-的-GIL"><a href="#如何处理-Python-的-GIL" class="headerlink" title="如何处理 Python 的 GIL"></a>如何处理 Python 的 GIL</h1><p>如果 GIL 给您带来问题，您可以尝试以下几种方法：</p>
<p><strong>多进程与多线程：</strong>最流行的方法是使用多进程方法，在这种方法中使用多个进程而不是线程。每个 Python 进程都有自己的 Python 解释器和内存空间，因此 GIL 不会成为问题。Python 有一个<code>multiprocessing</code>模块可以让我们像这样轻松地创建进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(processes=<span class="number">2</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    r1 = pool.apply_async(countdown, [COUNT//<span class="number">2</span>])</span><br><span class="line">    r2 = pool.apply_async(countdown, [COUNT//<span class="number">2</span>])</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Time taken in seconds -&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure>

<p>在我的系统上运行它会给出以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python multiprocess.py</span></span><br><span class="line">Time taken in seconds - 4.060242414474487</span><br></pre></td></tr></table></figure>

<p>与多线程版本相比，性能得到了不错的提升，对吧？</p>
<p>时间并没有减少到我们上面看到的一半，因为进程管理有它自己的开销。多进程的管理比多线程要重，因此请记住，这可能会成为性能扩展的瓶颈。</p>
<p><strong>选择另外的 Python 解释器：</strong> Python 有多个解释器实现。<a href="https://realpython.com/c-for-python-programmers/">分别用C</a>、<a href="https://realpython.com/oop-in-python-vs-java/">Java</a> 、C# 和 Python编写的CPython、Jython、IronPython 和<a href="https://realpython.com/pypy-faster-python/">PyPy</a>是最受欢迎的。GIL 仅存在于 CPython 的原始 Python 实现中。如果您的程序及其依赖库可用其他解释器实现，那么您也可以尝试它们。</p>
<p><strong>做等等党：</strong>虽然许多 Python 用户享受了 GIL 带来的单线程性能优势。但是多线程程序员也不必担心，因为 Python 社区中有一些最聪明的人正在努力从 CPython 中删除 GIL。其中一个比较出名尝试叫<a href="https://github.com/larryhastings/gilectomy">Gilectomy</a>。</p>
<p>Python 的GIL 通常被认为是Python 的一个疑难杂症。但请记住，作为 Pythonista，您通常只有在编写 C 扩展或在程序中使用CPU密集型的多线程时才会受到它的影响。</p>
<p>到此为止，本文应该向您提供了 GIL 是什么以及如何在您自己的项目中处理它所需的一切。如果您想了解 GIL 的低级内部工作原理，我建议您观看 David Beazley 的“<a href="https://youtu.be/Obt-vMVdM8s">了解 Python GIL”</a>演讲。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文在2018年前就写出来了，阅读时应考虑到Python在这个时间下的飞速发展~</p>
<p>原文翻译自   <a href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a>，目的是技术分享，如有侵权，请联系我删除。</p>
<p>希望大家能有所收获~</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>面试问题</tag>
        <tag>GIL</tag>
      </tags>
  </entry>
  <entry>
    <title>python中关键字梳理</title>
    <url>/2022/05/24/20220524_geek_Python%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<hr>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220524161536537.png" alt="image-20220524161536537"></p>
<p>在日常的开发过程中，Python的各类关键字（或者叫关键词）必不可少，那么，Python究竟有多少个关键字呢，每个关键字你都认识吗，它们的使用场景又是什么呢？本文将一一梳理如下。</p>
<h1 id="关键字（Keyword）的定义"><a href="#关键字（Keyword）的定义" class="headerlink" title="关键字（Keyword）的定义"></a>关键字（Keyword）的定义</h1><p>在编程中，关键字（Keyword）是编程语言的“保留词”，它对解释器而言代表着某种<strong>特殊含义</strong>。</p>
<p>因此，这些被编程语言预先定义和使用的关键字，<strong>是不能用作程序代码中的变量名、函数名及其他标识符的。</strong></p>
<h1 id="Python-中的关键字"><a href="#Python-中的关键字" class="headerlink" title="Python 中的关键字"></a><strong>Python 中的关键字</strong></h1><p>Python目前共有<strong>33</strong>个关键字，可以通过keyword库去获取所有的关键字列表：</p>
<p>代码输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用Kwlist方法打印所有的Python关键字</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The list of keywords is : &quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (keyword.kwlist)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">list</span> of keywords <span class="keyword">is</span> : </span><br><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="关键字列表"><a href="#关键字列表" class="headerlink" title="关键字列表"></a>关键字列表</h2><table>
<thead>
<tr>
<th>and</th>
<th>as</th>
<th>assert</th>
<th>break</th>
</tr>
</thead>
<tbody><tr>
<td><strong>class</strong></td>
<td><strong>continue</strong></td>
<td><strong>def</strong></td>
<td><strong>del</strong></td>
</tr>
<tr>
<td><strong>elif</strong></td>
<td><strong>else</strong></td>
<td><strong>except</strong></td>
<td><strong>False</strong></td>
</tr>
<tr>
<td><strong>finally</strong></td>
<td><strong>for</strong></td>
<td><strong>from</strong></td>
<td><strong>global</strong></td>
</tr>
<tr>
<td><strong>if</strong></td>
<td><strong>import</strong></td>
<td><strong>in</strong></td>
<td><strong>is</strong></td>
</tr>
<tr>
<td><strong>lambda</strong></td>
<td><strong>None</strong></td>
<td><strong>nonlocal</strong></td>
<td><strong>not</strong></td>
</tr>
<tr>
<td><strong>or</strong></td>
<td><strong>pass</strong></td>
<td><strong>raise</strong></td>
<td><strong>return</strong></td>
</tr>
<tr>
<td><strong>True</strong></td>
<td><strong>try</strong></td>
<td><strong>while</strong></td>
<td><strong>with</strong></td>
</tr>
<tr>
<td><strong>yield</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="如何判断是否是Python关键字"><a href="#如何判断是否是Python关键字" class="headerlink" title="如何判断是否是Python关键字"></a>如何判断是否是Python关键字</h2><p>同样，可以通过keyword的内置方法去做判断：</p>
<p>代码输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否是关键字</span></span><br><span class="line"><span class="built_in">print</span>(keyword.iskeyword(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(keyword.iskeyword(<span class="string">&#x27;class&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>让我们用一些例子对每个关键字进行讨论吧。</p>
<h1 id="关键字梳理"><a href="#关键字梳理" class="headerlink" title="关键字梳理"></a>关键字梳理</h1><h2 id="True-False-None"><a href="#True-False-None" class="headerlink" title="True, False, None"></a>True, False, None</h2><ul>
<li><p><strong>True：</strong>用来表示布尔真。如果表达式为真，则打印“True”。</p>
</li>
<li><p><strong>False：</strong>用来表示布尔假。如果表达式为假，则打印“False”。 </p>
</li>
<li><p><strong>None</strong>：这是一个特殊的常量，用于表示空值或无效值。<br>此处注意：<strong>0以及任何空容器（例如空列表、空字典等）都不是None。</strong><br><strong>None</strong>是NoneType类的对象。</p>
<p>True、False、None都可以当做不可变类型看待（类似int,str,tuple），因为所有引用他们的变量都指向同个内存地址。</p>
</li>
</ul>
<p>代码输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">False</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> == <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> + <span class="literal">True</span> + <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> + <span class="literal">False</span> + <span class="literal">False</span>)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="literal">None</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">None</span> == [])</span><br><span class="line"></span><br><span class="line">a = <span class="literal">None</span></span><br><span class="line">b = <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a) == <span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="and-or-not-in-is"><a href="#and-or-not-in-is" class="headerlink" title="and, or, not, in, is"></a>and, or, not, in, is</h2><ul>
<li><p><strong>and</strong>：是python中的逻辑运算符。<strong>“and”返回第一个布尔为假的值，如果没有找到就返回最后的值</strong>. “and”的真值表如下：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">A and B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">True</td>
<td align="center">True</td>
<td align="center">True</td>
</tr>
<tr>
<td align="center">True</td>
<td align="center">False</td>
<td align="center">False</td>
</tr>
<tr>
<td align="center">False</td>
<td align="center">True</td>
<td align="center">False</td>
</tr>
<tr>
<td align="center">False</td>
<td align="center">False</td>
<td align="center">False</td>
</tr>
</tbody></table>
<p>3 and 0 <strong>returns 0</strong> </p>
<p>3 and 10 <strong>returns 10</strong> </p>
<p>10 or 20 or 30 or 10 or 70 returns <strong>10</strong> </p>
<p>与像C语言这样的逻辑运算符总是返回布尔值（0 或 1）不同，因此上述语句可能有点令人困惑。按照python 文档的解释如下：</p>
<blockquote>
<p>表达式 x and y 首先计算 x；如果 x 为假，则返回其值；否则，计算 y 并返回结果值。</p>
<p>表达式 x or y 首先计算 x；如果 x 为真，则返回其值；否则，计算 y 并返回结果值。</p>
</blockquote>
</li>
</ul>
<p><strong>请注意，and 或 or 语句返回的不是True和False，而是返回布尔值为True和False的变量&#x2F;表达式的值。</strong></p>
<p>这有时很有用，例如要做这么一件事： s 是一个字符串，如果它是空的，则将其替换为默认值foo。则写法如下即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = s <span class="keyword">or</span> <span class="string">&#x27;foo&#x27;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果不了解这个特性，代码可能如下：</span></span><br><span class="line">s = s <span class="keyword">if</span> s <span class="keyword">else</span> <span class="string">&#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>PS. not 表达式&#x2F;参数  无论其参数的类型如何，它一定都会返回布尔值（例如，not ‘foo’ 会返回 False）</p>
<ul>
<li><strong>or</strong>：是python中的逻辑运算符。<strong>“or” 返回第一个布尔为真的值，如果没有找到就返回最后的值。</strong>“or”的真值表如下所示:</li>
</ul>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">A or B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">True</td>
<td align="center">True</td>
<td align="center">True</td>
</tr>
<tr>
<td align="center">True</td>
<td align="center">False</td>
<td align="center">True</td>
</tr>
<tr>
<td align="center">False</td>
<td align="center">True</td>
<td align="center">True</td>
</tr>
<tr>
<td align="center">False</td>
<td align="center">False</td>
<td align="center">False</td>
</tr>
</tbody></table>
<p>3 or 0 <strong>returns 3</strong> </p>
<p>3 or 10 <strong>returns 3</strong> </p>
<p>0 or 0 or 3 or 10 or 0 returns <strong>3</strong> </p>
<p>类似and。</p>
<ul>
<li><strong>not：</strong>此逻辑运算符用来反转布尔值。 </li>
<li><strong>in：</strong>该关键字用来检查容器（list,dict,set等）内的元素是否包含要检测的值。该关键字也用于循环容器。</li>
<li><strong>is：</strong>此关键字用来检测对象的一致性，即检查两个对象是否指向同一内存地址。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">3</span> <span class="keyword">or</span> <span class="number">10</span> <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line">Output:<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">and</span> <span class="number">10</span>)</span><br><span class="line">Output:<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">True</span>)</span><br><span class="line">Output:<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ai&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;bain&#x27;</span>)</span><br><span class="line">Output:<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;bain&#x27;</span>:</span><br><span class="line">	<span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">Output:b a i n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(&#123;&#125; <span class="keyword">is</span> &#123;&#125;)</span><br><span class="line">Output:<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line">Output:<span class="literal">True</span> <span class="comment"># 对于不可变类型，内存地址相同，变量指向同一内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(&#123;&#125; <span class="keyword">is</span> &#123;&#125;)</span><br><span class="line">Output:<span class="literal">False</span> <span class="comment"># 对于可变类型，内存地址不相同，变量指向不同内存地址</span></span><br></pre></td></tr></table></figure>

<h2 id="for、while、break、continue"><a href="#for、while、break、continue" class="headerlink" title="for、while、break、continue"></a>for、while、break、continue</h2><ul>
<li><strong>for</strong>：此关键字用于创建循环语句。</li>
<li><strong>while</strong>：类似“for”，用于创建循环语句。</li>
<li><strong>break</strong>： 该关键字用于跳出循环体并将执行权传递给紧跟在循环之后的语句。</li>
<li><strong>continue</strong>：该关键字会跳过循环的当前迭代进入下一迭代，但不结束循环。</li>
</ul>
<p>代码输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用for循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	<span class="built_in">print</span>(i, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="comment"># 当循环到6时，跳出循环，执行循环体后面的print语句</span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">6</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 使用while循环</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;<span class="number">10</span>:</span><br><span class="line">	<span class="comment"># 当i=6时，跳出当前迭代，进入下一迭代，并不结束循环</span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">6</span>:</span><br><span class="line">		i+= <span class="number">1</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 当i不等于6时，打印i，并用空格分开</span></span><br><span class="line">        <span class="built_in">print</span>(i, end = <span class="string">&quot; &quot;</span>)  </span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="if、else、elif"><a href="#if、else、elif" class="headerlink" title="if、else、elif"></a>if、else、elif</h2><ul>
<li><strong>if</strong>：用于条件判断的控制语句。<strong>表达式为真值则进入“if”语句块。</strong></li>
<li><strong>else</strong>：用于条件判断的控制语句。<strong>表达式为假值进入“else”语句块。</strong></li>
<li><strong>elif</strong>：用于条件判断的控制语句。它是“ <strong>else if</strong> ”的缩写</li>
</ul>
<p>代码输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">10</span>):</span><br><span class="line">	<span class="built_in">print</span> (<span class="string">&quot;i is 10&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (i == <span class="number">20</span>):</span><br><span class="line">	<span class="built_in">print</span> (<span class="string">&quot;i is 20&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span> (<span class="string">&quot;i is not present&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i <span class="keyword">is</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="def"><a href="#def" class="headerlink" title="def"></a>def</h2><p>def 关键字用于声明用户自定义的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># def keyword</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Inside Function&quot;</span>)</span><br><span class="line">	</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Inside Function</span><br></pre></td></tr></table></figure>

<h2 id="Return-Yield"><a href="#Return-Yield" class="headerlink" title="Return, Yield"></a><strong>Return, Yield</strong></h2><ul>
<li><strong>return ：</strong>此关键字用于从函数返回值。</li>
<li><strong>yield ：</strong>此关键字与 return 语句类似，但用于返回生成器。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Return 关键字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">	S = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">		S += i</span><br><span class="line">	<span class="keyword">return</span> S</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fun())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Yield 关键字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">	S = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">		S += i</span><br><span class="line">		<span class="keyword">yield</span> S</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fun():</span><br><span class="line">	<span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">10</span> <span class="number">15</span> <span class="number">21</span> <span class="number">28</span> <span class="number">36</span> <span class="number">45</span> </span><br></pre></td></tr></table></figure>

<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p><strong>class</strong>关键字用于声明用户自定义的类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 类属性</span></span><br><span class="line">	attr1 = <span class="string">&quot;mammal&quot;</span></span><br><span class="line">	attr2 = <span class="string">&quot;dog&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 实例方法</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;I&#x27;m a&quot;</span>, self.attr1)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;I&#x27;m a&quot;</span>, self.attr2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化类，得到一个对象</span></span><br><span class="line">Rodger = Dog()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类属性和实例方法</span></span><br><span class="line"><span class="built_in">print</span>(Rodger.attr1)</span><br><span class="line">Rodger.fun()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mammal</span><br><span class="line">I<span class="string">&#x27;m a mammal</span></span><br><span class="line"><span class="string">I&#x27;</span>m a dog</span><br></pre></td></tr></table></figure>

<h2 id="With"><a href="#With" class="headerlink" title="With"></a>With</h2><p><strong>with</strong>关键字用于将一些逻辑的执行包装在上下文管理器定义的方法中。在运行函数之前和运行函数之后执行一些操作（最常见的就是with open，用于最后关闭文件，如果不用with，则需要显式的写出close）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># using with statement</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file_path&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">	file.write(<span class="string">&#x27;hello world !&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="as"><a href="#as" class="headerlink" title="as"></a>as</h2><p><strong>as</strong>关键字用于为导入的模块创建别名。即给导入的模块一个新名称。例如，导入math，别名为 mymath。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> mymath</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mymath.factorial(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">Out:<span class="number">120</span></span><br></pre></td></tr></table></figure>

<h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><p><strong>pass</strong>是python中的空语句。执行此语句时不具体执行任何逻辑。用作占位符防止发生缩进错误。（比如我先定义了很多需要用到的函数，但是还没想好怎么写内部逻辑，先写个pass在函数体防止IDE执行报错；或者一些抽象函数也会用到pass）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 10</span><br><span class="line">for i in range(n):</span><br><span class="line">	# 用作占位符，等待后续增加具体代码</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>

<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda关键字用于用于创建小型匿名函数。 Lambda 函数可以接受任意数量的参数，但只能拥有一个表达式。 这个表达式会被计算并返回结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Lambda keyword</span></span><br><span class="line">g = <span class="keyword">lambda</span> x: x*x*x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(g(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">Output:<span class="number">343</span></span><br></pre></td></tr></table></figure>

<h2 id="Import-From"><a href="#Import-From" class="headerlink" title="Import, From"></a>Import, From</h2><ul>
<li><strong>import</strong>：此语句用于将特定模块导入到当前程序中。</li>
<li><strong>from ：</strong>通常与 import 一起使用，from 用于指定从什么模块导入。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import keyword</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.factorial(<span class="number">10</span>))</span><br><span class="line">Output:<span class="number">3628800</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># from keyword</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> factorial</span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">10</span>))</span><br><span class="line">Output:<span class="number">3628800</span></span><br></pre></td></tr></table></figure>

<h2 id="try-except-raise-finally-and-assert"><a href="#try-except-raise-finally-and-assert" class="headerlink" title="try, except, raise, finally, and assert"></a>try, except, raise, finally, and assert</h2><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220524195923502.png" alt="image-20220524195923502"></p>
<ul>
<li><strong>try ：</strong>该关键字用于异常处理：执行“try”代码块中的代码，如果有任何类型的错误，就会跳到except语句去捕获。</li>
<li><strong>except ：</strong>与“try”一起使用以捕获异常。</li>
<li><strong>finally ：</strong>无论“try”块有无异常，“finally”的块总是最后被执行。</li>
<li><strong>raise：</strong>可以使用 raise 关键字显式地引发异常</li>
<li><strong>assert：</strong>断言关键字，此函数用于<strong>调试目的</strong>。通常用于检查代码的正确性。如果一个语句被评估为真（assert True），则什么也不会发生，但是当它为假时（assert False），会引发<strong>“ AssertionError ”。</strong>也可以<strong>打印带有错误的消息，用逗号分隔</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能存在异常的代码块</span></span><br><span class="line">	k = a//b </span><br><span class="line">	<span class="built_in">print</span>(k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理除0异常</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t divide by zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无论代码被捕获异常，都执行finally块内的语句</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;This is always executed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># assert断言</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The value of a / b is : &quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> b != <span class="number">0</span>, <span class="string">&quot;断言b不是0，如果是0，则抛出AssertionError异常&quot;</span></span><br><span class="line"><span class="built_in">print</span> (a / b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Can<span class="string">&#x27;t divide by zero</span></span><br><span class="line"><span class="string">This is always executed</span></span><br><span class="line"><span class="string">The value of a / b is :</span></span><br><span class="line"><span class="string">AssertionError: Divide by 0 error</span></span><br></pre></td></tr></table></figure>

<h2 id="del"><a href="#del" class="headerlink" title="del"></a><strong>del</strong></h2><p>del 用于删除对对象的引用（需要先了解python对内存回收的引用计数机制）。可以使用 del 删除任何变量或列表值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_variable1 = <span class="number">20</span></span><br><span class="line">my_variable2 = <span class="string">&quot;GeeksForGeeks&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查变量 my_variable1 和 my_variable2 是否存在</span></span><br><span class="line"><span class="built_in">print</span>(my_variable1)</span><br><span class="line"><span class="built_in">print</span>(my_variable2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除这两个变量对其值的引用</span></span><br><span class="line"><span class="keyword">del</span> my_variable1</span><br><span class="line"><span class="keyword">del</span> my_variable2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次检查变量 my_variable1 和 my_variable2 是否存在</span></span><br><span class="line"><span class="built_in">print</span>(my_variable1)</span><br><span class="line"><span class="built_in">print</span>(my_variable2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line">GeeksForGeeks</span><br><span class="line">NameError: name <span class="string">&#x27;my_variable1&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<h2 id="Global-Nonlocal"><a href="#Global-Nonlocal" class="headerlink" title="Global, Nonlocal"></a>Global, Nonlocal</h2><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220524200250850.png" alt="image-20220524200250850"></p>
<ul>
<li><strong>global：</strong>此关键字用于将函数内部的变量声明为全局变量。</li>
<li><strong>nonlocal ：</strong>此关键字的作用类似于 global，此关键字声明一个变量为外部函数的变量。</li>
</ul>
<p>PS. 具体知识可以去查询“Python中变量的作用域”相关知识。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">a = <span class="number">15</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">	c = a + b</span><br><span class="line">	<span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">	var1 = <span class="number">10</span> <span class="comment"># 局部变量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">gun</span>():</span><br><span class="line">		<span class="comment"># 声明嵌套函数内部的变量为上一层函数的变量（指向同一块内存地址）</span></span><br><span class="line">		<span class="keyword">nonlocal</span> var1</span><br><span class="line">		</span><br><span class="line">		var1 = var1 + <span class="number">10</span></span><br><span class="line">		<span class="built_in">print</span>(var1)</span><br><span class="line"></span><br><span class="line">	gun()</span><br><span class="line">fun()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文梳理了python内所有关键字的含义及基本使用示例，希望对你有帮助~</p>
<p>本文大量参照了<a href="https://www.geeksforgeeks.org/python-keywords/">https://www.geeksforgeeks.org/python-keywords/</a>的内容，目的是技术分享，如有侵权，请联系我删除。</p>
<p>希望大家能有所收获~</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>geeksforgeeks</tag>
        <tag>keywords</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的命名空间和作用域</title>
    <url>/2022/05/30/20220527_program_Python%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<hr>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220527181041536.png" alt="image-20220527181041536"></p>
<p>日常的Python开发中，变量的使用是一个简单但是不注意又会出错的地方，本文从变量的命名空间（NameSpace）和作用域（Scope）的角度去讲解他们的含义和与变量的关系。</p>
<h1 id="变量名在Python中的含义"><a href="#变量名在Python中的含义" class="headerlink" title="变量名在Python中的含义"></a>变量名在Python中的含义</h1><p>如果您曾经阅读过“ python之禅”（在Python解释器中输入 <code>import this</code>），则会看到最后一行是，</p>
<p><code>Namespaces are one honking great idea -- let&#39;s do more of those!</code></p>
<p>翻译过来就是：<strong>命名空间是个绝妙的主意，我们应好好利用它。</strong></p>
<p>那么到底什么是命名空间(NameSpace)呢？让我们首先看一下什么叫做变量名(Name)吧。</p>
<p>变量名（Name），或者叫变量标识符（Identifier），简单理解就是某个python对象的名字，而我们知道：Python 中的一切都是对象。变量名是访问底层对象的一种方式。</p>
<p>例如，当我们进行赋值时：<code>a = 2</code>，<code>2</code>是一个存储在内存中的对象，而a是我们与之关联的名称。我们可以通过内置函数<code>id()</code>获取某个对象在内存中的地址。让我们看看它的使用范例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(2) =&#x27;</span>, <span class="built_in">id</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(a) =&#x27;</span>, <span class="built_in">id</span>(a))</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>(<span class="number">2</span>) = <span class="number">140728274186016</span></span><br><span class="line"><span class="built_in">id</span>(a) = <span class="number">140728274186016</span></span><br></pre></td></tr></table></figure>

<p>在这里，两者都指向同一个对象<code>2</code>，因此它们具有相同的<code>id()</code>。让我们让事情变得更有趣一些。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(a) =&#x27;</span>, <span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">a = a+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(a) =&#x27;</span>, <span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(3) =&#x27;</span>, <span class="built_in">id</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(b) =&#x27;</span>, <span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(2) =&#x27;</span>, <span class="built_in">id</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>(a) = <span class="number">140728274186016</span></span><br><span class="line"><span class="built_in">id</span>(a) = <span class="number">140728274186048</span></span><br><span class="line"><span class="built_in">id</span>(<span class="number">3</span>) = <span class="number">140728274186048</span></span><br><span class="line"><span class="built_in">id</span>(b) = <span class="number">140728274186016</span></span><br><span class="line"><span class="built_in">id</span>(<span class="number">2</span>) = <span class="number">140728274186016</span></span><br></pre></td></tr></table></figure>

<p>上述程序的在执行中发生了什么？让我们用一张图来解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220530192110203.png" alt="image-20220530192110203"></p>
<p>最初，一个整型对象<code>2</code>被我们创建了，并且用<code>a</code>作为变量名（标识符）与之关联（可以理解为贴标签），当我们这样执行<code>a = a+1</code>时，一个新的整型对象<code>3</code>被我们创建了（先执行左边的语句，创建了3这个对象），此时<code>a</code>与3关联（再执行赋值语句，可以理解为标签从<code>2</code>上面撕下来贴到对象<code>3</code>的上面）。</p>
<p>此时，id(a)和id(3)的值是相同的，他们都指向内存中存放整型对象3的地址。</p>
<p>此外，当执行<code>b=2</code>时，一个新的变量名（标签）与整型对象<code>2</code>相关联（把b这个标签贴到了整型对象2上面）</p>
<p>因为这种方式对于Python来说不用每次赋值都创建一个新的对象（取而代之只是增加或者更换标签），因此是足够高效的。变量名绑定这种动态的特性使得Python更强大。变量名可以指代任何类型的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>上面的代码中，变量名a分别指代了3种对象（整型，字符串，列表）的实例，并且这些语句都可以成功执行，而在Python中，函数也是一种对象，因此变量名同样可以指代函数。（给函数贴上标签）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printHello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = printHello</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p><code>a</code>同样可以指向一个函数，并且我们可以通过变量名<code>a</code>调用这个函数。</p>
<h1 id="在Python中，命名空间是什么呢"><a href="#在Python中，命名空间是什么呢" class="headerlink" title="在Python中，命名空间是什么呢"></a>在Python中，命名空间是什么呢</h1><p>既然我们已经理解了变量名（<code>Name</code>）是什么，我们现在可以来讨论命名空间（<code>NameSpace</code>）的概念了。</p>
<p>简单的说，命名空间（<code>NameSpace</code>）就是一组变量名（<code>Name</code>）的集合。</p>
<p>在 Python 中，您可以将命名空间想象为您定义的每个变量名到相应对象的映射集。</p>
<p>不同的命名空间可以在给定时间共存，但是是完全隔离的。</p>
<p>当我们启动 Python 解释器时，会创建一个包含所有内置名称（<code>built-in</code>）的命名空间，并且只要解释器运行，它就存在。</p>
<p>这就是我们始终可以从程序的任何部分使用诸如 <code>id(), print()</code>等内置函数的原因。每个模块（<code>module</code>）都会创建自己的全局命名空间。</p>
<p>这些不同的命名空间是相互隔离的。因此，不同模块中可能存在相同的变量名且不会发生冲突。</p>
<p>每个模块可以定义不同的函数和类。当函数被调用时会创建一个本地命名空间，其中包含了所有在此函数内定义的变量名。类的情况与函数类似。下图可能有助于理解这个概念。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220530195031406.png" alt="image-20220530195031406"></p>
<h1 id="Python中的变量作用域（Scope）"><a href="#Python中的变量作用域（Scope）" class="headerlink" title="Python中的变量作用域（Scope）"></a>Python中的变量作用域（Scope）</h1><p>尽管定义了各种独一无二的命名空间，但我们是无法在程序的每个地方都可以访问到全部的命名空间的。这就是作用域的概念。</p>
<p>作用域是程序的一部分，它表示代码在运行时可以直接获取到的命名空间。</p>
<p>在程序运行的任何时刻，至少有三个互相嵌套的作用域：</p>
<ol>
<li>当前函数的作用域：对于函数内定义的变量（本地变量名→本地命名空间）</li>
<li>当前模块的作用域：对于模块内定义的变量名（全局变量名→全局命名空间）</li>
<li>最外层作用域：内置的变量名（所有预先定义的内置变量名→内置命名空间）</li>
</ol>
<p>当在函数内部进行变量名的引用时，会在本地命名空间中搜索，然后在全局命名空间中搜索，最后在内置命名空间中搜索。</p>
<p>如果在一个函数内部另有一个函数，则一个新作用域（内部函数）嵌套在本地命名空间内。</p>
<h1 id="Python中命名空间和作用域的例子"><a href="#Python中命名空间和作用域的例子" class="headerlink" title="Python中命名空间和作用域的例子"></a>Python中命名空间和作用域的例子</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>():</span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_func</span>():</span><br><span class="line">        c = <span class="number">30</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>这里，变量<code>a</code>位于全局命名空间中。变量<code>b</code>位于函数<code>outer_function()</code>的本地命名空间中。<code>c</code>位于嵌套函数<code>inner_func</code>内的本地命名空间中。</p>
<p>如果我们在<code>inner_func</code>中尝试给<code>b</code>赋值，一个新的变量名会被创建在本地命名空间中，并且与上层函数中的<code>b</code>并不相同（因为不在同一命名空间内，所以不会指向同一内存地址），当我们尝试给<code>a</code>赋值时同理。</p>
<p>然而，如果我们在内部作用域声明变量名<code>a</code>是全局变量（global），那么所有对a的赋值和引用都会指向这个全局变量<code>a</code>。相似的，如果我们想在<code>inner_func</code>函数里绑定变量名<code>b</code>，使得引用和指代都是<code>outer_function</code>内的<code>b</code>，那么我们必须在<code>inner_func</code>中声明<code>b</code>为非本地变量（nolocal）。下面的例子更清楚的说明了这件事。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>():</span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>():</span><br><span class="line">        a = <span class="number">30</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line">    inner_function()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">outer_function()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a)</span><br></pre></td></tr></table></figure>

<p>如您所想，该程序输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">30</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">a = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>在这个程序中，三个不同变量名a在独立的三个命名空间中被定义并且被顺序的访问。而在下面的程序中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>():</span><br><span class="line">        <span class="keyword">global</span> a</span><br><span class="line">        a = <span class="number">30</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line">    inner_function()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">outer_function()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a)</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">30</span></span><br><span class="line">a = <span class="number">30</span></span><br><span class="line">a = <span class="number">30</span> </span><br></pre></td></tr></table></figure>

<p>在这里，由于使用了关键字<code>global</code>，因此所有的引用和赋值都是针对全局变量<code>a</code>而进行的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对python中变量的命名空间和作用域进行了讲解和示例 ，希望对你有帮助~</p>
<p>本文大量参照了<a href="https://www.programiz.com/python-programming/namespace%E3%80%82">https://www.programiz.com/python-programming/namespace。</a></p>
<p>希望大家能有所收获~</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>programiz</tag>
        <tag>namespace,scope</tag>
      </tags>
  </entry>
  <entry>
    <title>AIOps中的时序数据应用</title>
    <url>/2022/06/28/20220628_AIOps%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着科技的发展，时序数据在我们的认知中占据越来越多的位置，小到电子元件在每个时刻的状态，大到世界每天的新冠治愈人数，一切<strong>可观测，可度量，可统计</strong>的数据只要带上了时间这个重要的因素就会成为时序数据。在运维领域，时序数据的范围则缩小到软件系统及其关联事物上面。随着数字化，物联网，人工智能等新技术的蓬勃发展，时序数据也运维领域也产生了爆发的增长，<strong>那么，究竟什么是时序数据，时序数据在智能运维（AIOps）领域又能为人们带来哪些价值呢？</strong>本文将会围绕这两点进行阐述，并拓展介绍一些具体应用时序数据的算法。</p>
<h2 id="时序数据"><a href="#时序数据" class="headerlink" title="时序数据"></a>时序数据</h2><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220629100952827.png" alt="image-20220629100952827"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单的说，<strong>时序数据就是一串按时间维度索引的数据</strong>。具体的说，时序数据描述了某个被测量的<strong>对象</strong>每个<strong>时间点</strong>上的<strong>测量值</strong>，时间点之间的间隔如果保持不变，比如都是1分钟，那么可以说这个时序数据的时间粒度&#x2F;时间间隔&#x2F;频率为1分钟。</p>
<p>从上述对时序数据的定义来看，时序数据由三个部分组成：<strong>对象，时间点，测量值</strong>。一切满足这三个部分的组合，都可以称作时序数据。只要想一想，就会发现，这类组合无处不在：<u>人体</u> 每分钟 <del>的</del> <u>心率</u>，cpu <u>每秒</u> <del>的</del> 使用率，<u>网站</u> <u>每小时</u> <del>的</del> <u>访问量</u>，<u>手机网络</u> <u>每秒</u> <u>下载的数据量</u>，……，下面我们对这三个部分进行进一步解释：</p>
<span id="more"></span>

<p><strong>对象</strong>：即被测量的主体是什么，一个对象可以有多个维度的属性。以cpu对象为例，可以是A集群、B物理机、C虚拟机的cpu，那么A,B,C就是cpu对象的3个维度属性。</p>
<p><strong>时间点</strong>：即对象被测量时的时间位置，一般用时间戳表示。比如上述cpu对象在2022年6月29日上午8点12分38秒被测量了一次，那么这个时间就是时间点。</p>
<p><strong>测量值</strong>：一个对象可能有多个测量值，每个测量值都对应一种指标。仍以上面的cpu为例，我们可以测量它在对应时间点的<u>使用率</u>，也可以测量它的当前<u>使用值</u>。</p>
<p>总的来说，每条时序数据都由对象、时间点、测量值三个部分组成，同一对象的时序数据记录了该对象在时间维度上的状态变化信息，对时序数据的分析就是挖掘时序数据蕴含的规律的过程。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>时序数据相较其他类型数据有一些显著特点：</p>
<ul>
<li><strong>数据一定带有时间字段&#x2F;索引</strong></li>
<li><strong>数据按时间粒度稳定且持续的产生</strong></li>
<li><strong>数据基本不会有更新操作</strong></li>
<li><strong>一般而言数据会随着时间流逝价值逐渐降低，具有时效性</strong></li>
<li><strong>数据的处理必须结合时间属性</strong></li>
</ul>
<p>针对时序数据的特点，业界有很多时序数据库专门用来高效的存储时序数据，如influxdb,Prometheus等。</p>
<h2 id="AIOps中的时序数据"><a href="#AIOps中的时序数据" class="headerlink" title="AIOps中的时序数据"></a>AIOps中的时序数据</h2><p>上面对什么是时序数据以及时序数据的特性做了介绍，接下来我们看下在AIOps领域，时序数据又有怎么样的应用。</p>
<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>在运维领域，为了保障整个软件系统的正常运行，需要在系统的各个层次定义要观测的时序数据，即定义要<strong>监控的指标</strong>。一般地，成熟的监控指标体系的搭建是以CMDB为骨架，以监控指标为脉络而进行的。因此，在AIOps中，时序数据的表现为监控指标。下图展示了运维领域中监控指标的体系层次，这是运维中的另一个大领域，如感兴趣可参详文章：【监控宣传文章链接】。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220628173240501.png" alt="image-20220628173240501"></p>
<h3 id="在AIOps中的应用方向"><a href="#在AIOps中的应用方向" class="headerlink" title="在AIOps中的应用方向"></a>在AIOps中的应用方向</h3><p>指标（Metric），日志（Log），调用链（Trace）是运维领域中产生的较为普遍的三种数据类型，因此基于运维数据之上的AIOps对于指标数据的利用也非常广泛，下面对应用成熟度比较高的两个方向进行探讨：<strong>1）指标异常检测；2）指标预测</strong>。</p>
<h4 id="指标异常检测"><a href="#指标异常检测" class="headerlink" title="指标异常检测"></a>指标异常检测</h4><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220629102426534.png" alt="image-20220629102426534"></p>
<p>指标异常检测，即判断监控指标体系中的对象指标是否发生了异常情况的过程。如果把软件系统比作人体，那么运维对象指标就对应人体的心率，血压，血糖，视力，激素水平等生理指标（类似上图），运维监控工具则对应各类用于检测的医疗设备。</p>
<p>需要保证软件系统的正常运行，首先就需要将表征&#x2F;反映其是否健康的指标监控起来，然后再用异常检测算法进行实时或准实时的判断，当出现异常情况时能通过告警工具及时通知运维人员进行进一步检查，以决定是否采取相关措施。就像电视剧里一样，病人生病了，各类仪器在实时监控着病人的情况，当发现监控指标出现异常，就需要及时通知医生查看情况。而在运维领域，为了保证软件系统的高可用性，在软件系统的全生命周期都需要配备监控，并设定异常检测算法，不管是简单的静态阈值还是复杂的算法策略。</p>
<h5 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h5><p>指标的异常，一般指监控对象的指标出现了不符合预期或者不符合正常情况下的变化。比如页面访问成功率突然的下跌，cpu使用率的飙升，内存使用率的缓慢增长（内存泄漏），周末业务量相较过往下跌等等，这里需要明确的是大部分指标的异常并不代表软件系统发生了故障。</p>
<p>另一方面，异常的判断通常需要结合具体的业务情况进行，因为数学统计上的异常不代表实际业务上发生了异常，二者的判断标准是不一样的，在实际的异常检测落地时不能忘记考虑这一点，否则算法就成自嗨的玩具了。</p>
<p>下面对常见的一些指标异常情况进行梳理：</p>
<ul>
<li>离群点异常：即当前的指标值与附近时间点的指标值差距较大，或者当前指标值与整个时间窗口内的指标值差距都较大。比如意外的下降或者上升，或者出现整个窗口内的峰值。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220629145727938.png" alt="image-20220629145727938"></p>
<ul>
<li>变点(change point)异常：即该指标的出现不但不符合之前的趋势，并且还改变了之后指标的趋势，相当于在这个时间点的前后，指标的表现是两个模式。比如旅游人数，每年10月1日前后会持续10天左右高峰，与平时的情况大为不同，这里的变点可能就是9月30日（放假开始前夕）。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220629150449582.png" alt="image-20220629150449582"></p>
<ul>
<li>周期性异常：在周期性指标数据内，某个时间点的指标表现不符合它以往的指标值。比如每晚10点都是英雄联盟游戏的在线人数高峰，但是某天晚10点进行了部分大区的版本更新，导致在线人数不符合之前同时间点的表现。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220629153605367.png" alt="image-20220629153605367"></p>
<ul>
<li>其他类异常：比如上面谈到的内存泄露，对于很多指标下图的表现都不能算异常，但是对于内存指标而言却可以肯定的说出现了内存泄露的异常。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220629162848632.png" alt="image-20220629162848632"></p>
<h4 id="指标预测"><a href="#指标预测" class="headerlink" title="指标预测"></a>指标预测</h4><p>指标预测，即通过对指标历史数据的分析，挖掘其存在的内部规律（比如趋势性，周期性等），根据这些规律对未来一段时间内的指标值进行预测。比如对业务量进行预测，判断未来半年需要投入多少成本来达到最优成本配置。甚至还可以对股市进行预测，当然，因为股市影响因素极多，很难只从时序数据本身挖掘到规律，自然预测的结果也就毫不可信了。</p>
<p>在AIOps领域，指标预测的应用方向一般有两个：</p>
<p><strong>1）指标异常检测</strong>：一般使用单步预测即可满足，通过对比预测值和实际值的差异判断数据的异常程度。常用的如移动平均（MA），1阶，2阶，3阶指数平滑等统计类算法。</p>
<p><strong>2）较长期资源量的预测</strong>：比如存储资源、计算资源、网络资源、资源池等未来使用量的预测。对于业务上公有云的公司来说，资源即成本，能在满足业务使用及一定冗余的情况下尽可能的减少资源的购买量，能够显著提升效益，再配合上自动化工具，即可完成自动扩缩容的场景。对于另一些需要采购资源周期比较长的公司来说，能根据过去资源的使用情况预测下半年或者下半年的资源预算是非常重要的，这能尽量使得资源利用率得到提高。</p>
<p>下图是一个时序预测的样例图：</p>
<p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220629155745065.png" alt="image-20220629155745065"></p>
<h4 id="方法汇列"><a href="#方法汇列" class="headerlink" title="方法汇列"></a>方法汇列</h4><p>对于异常检测算法，目前来看大致可以分为以下几种：</p>
<ul>
<li><strong>统计类算法</strong>：复杂度低，计算速度快，泛化能力强，不需要大量的带标签数据做训练。但是某些算法的适用需要先验的了解指标的统计分布特性，并且无法“进化”，因为本质上还是属于某种规则。</li>
<li><strong>机器学习算法</strong>：鲁棒性较好，准确率较高。有的需要进行特征工程，训练模型，泛化能力一般。</li>
<li><strong>深度学习算法</strong>：计算复杂度高，需要进行特征工程，并且需要大量的数据进行训练，对于新标签可以重新训练，“进化”的越来越准。整体来看准确度高。</li>
</ul>
<p>但是在运维领域，机器学习和深度学习模型会有“水土不服”的现象，主要体现为：</p>
<p>1）异常点的判定标准不统一，如上所说，是需要结合业务情况的，而业务情况通常千奇百怪，难以有统一的异常判断标准对所有业务数据进行打标签工作。异常判断标准不同会导致模型的复用性变差，不能覆盖所有指标。</p>
<p>2）标签工具与工作量，通常而言运维人员会面对数以万计乃至百万千万计的监控指标，打标签工具如何与大量的指标结合呢，打标签这么枯燥而繁杂的工作量消耗的人员成本也是巨大的，需要懂各类业务指标，并且能准确的标记，这是很难做到的，而一旦标签数据不准确，就会导致模型的准确率下降。</p>
<p>3）正负标签的样本量差距极大，在目前可用性极高的软件系统中，异常的指标一般占比不足1%，如何平衡正负样本的数量也是需要解决的问题。</p>
<p>4）模型管理与部署，随着业务变更，资源扩缩，指标的形态是会发生变化的，当模型的准确率下降，是需要重新训练和部署模型的，这其中涉及到MLOps的持续训练了（CT，Continuous Training），需要工程化的流程来支撑，复杂度进一步加大。</p>
<p>5）特征工程，对于时序数据，通常会生成各类时序特征后再输入模型，特征工程的计算量及耗时对于实时性要求比较高的指标异常检测可能是个需要考虑的问题。</p>
<p>考虑到指标异常检测的费效比，是否要上机器学习乃至深度学习模型值得三思。</p>
<p>目前，统计类&#x2F;无监督学习的算法在异常检测场景中因为“更接地气”，因此也更多的被运维工具&#x2F;平台所采用。下面列举了一些常用的统计类和无监督机器学习算法，在后面算法介绍的部分会有进一步的说明。</p>
<ul>
<li><strong>统计类算法</strong>：Nsigma（含一阶差分与不差分两类），箱线图，EWMA，KDE</li>
<li><strong>无监督机器学习算法</strong>：DBSCAN，孤立森林，LOF局部异常因子，OneClassSVM</li>
</ul>
<p>对于指标预测算法，从不同的角度看有不同的分类：</p>
<blockquote>
<ul>
<li>从实现原理的角度，可以分为传统统计学，机器学习（又分非深度学习和深度学习）。</li>
<li>按预测步长区分，可以分为单步预测和多步预测，简单来说就是一次预测未来一个时间单元还是一次预测未来多个时间单元的区别。</li>
<li>按输入变量区分，可以分为自回归预测和使用协变量进行预测，区别在于维度中是否含有协变量，例如预测未来销售量时，如果只接受时间和历史销售量数据，则是自回归预测，如果可以接受天气、经济指数、政策事件分类等其他相关变量（称为协变量），则称为使用协变量进行预测。</li>
<li>按输出结果区分，可以分为点预测和概率预测，很多模型只提供了点预测而不提供概率预测，点预测模型后再加蒙特卡洛模拟（或其他转化为概率预测的方式）往往不能准确反映模型输出的预测概念，而在大多数场景下，概率预测更贴近事实情况，对于未来的预测本身就应该是一种概率分布。</li>
<li>按目标个数区分，可以分为一元、多元、多重时间序列预测。举例理解，使用历史的销售量预测未来1天的销售量为一元时间序列预测，使用历史的进店人数、销售量、退货量预测未来1天的进店人数、销售量、退货量（预测目标有三个）为多元时间序列预测，使用历史的红烧牛肉面、酸菜牛肉面、海鲜面的销售量预测未来1天的红烧牛肉面、酸菜牛肉面、海鲜面的销售量（预测目标有三种）为多重时间序列预测。[<a href="https://aws.amazon.com/cn/blogs/china/time-series-prediction-with-deep/">1]</a></li>
</ul>
</blockquote>
<p>预测类的算法非常多，有的原理及使用非常复杂，这里只列出几种比较常用的且在AIOps实践中落地过的算法，同样，在后面的算法介绍部分对涉及到的算法会有进一步的说明。</p>
<ul>
<li><strong>统计类算法</strong>：prophet，holt-winters，SARIMA</li>
<li><strong>机器学习类算法（非深度学习）</strong>：回归类算法（包括LR及正则化LR，XGBoost回归）</li>
</ul>
<h4 id="适用性分类"><a href="#适用性分类" class="headerlink" title="适用性分类"></a>适用性分类</h4><p>在AIOps应用上述算法时，经常会碰到使用者提出的一个问题：<strong>这么多算法，我到底该用哪一个。</strong>别急，在明确回答这个问题之前，我们需要再掌握一些时序数据相关的知识，才能更好的给出这个问题的答案。</p>
<p>时序数据的平稳性：<strong>如果某条时序数据不会随着时间的推移而改变其统计特性，那么我们可以说这条时序数据是平稳的。</strong>这里的统计特性指的是这条时序数据的均值、方差以及其第t项与第(t+m)项数值的协方差。</p>
<p>这里用非正式的语言解释下这些统计特性的含义，可能不够严谨：均值不变代表整个时序数据是否是围绕某条线（均值线）上下波动的，比如下图左侧三条曲线都是围绕y&#x3D;5波动的；方差不变代表整个时序数据的波动幅度是否是不变的，同理下图左侧的波动幅度是不变的（测量值最大是10，最小是0，围绕均值5最大波动幅度为5）；第t项与第(t+m)项数值的协方差不变，代表着固定数据间隔下数据的走势是相同的，可以简单的理解为数据的周期是不变的。</p>
<p>下面给出示例图辅以说明：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220630165337250.png" alt="image-20220630165337250"></p>
<p>为什么平稳性如此重要？因为对平稳序列进行分析很容易，因为可以假设未来的统计特性与目前观测到的统计特性是一致的，这使得大多数时间序列算法都以这样或那样的方式去利用这些属性(例如均值或方差)。如果原始序列不是平稳的，未来的预测将可能是错误的。很不幸，在实际应用中大多数的时间序列都是非平稳的。但好消息是消除时间序列非平稳性的方法有很多，常用的有：多阶差分、移除趋势和季节性去除、平滑，以及 Box-Cox 或对数等转换。</p>
<p>因此，对于异常检测算法的选择有如下建议：</p>
<ol>
<li>如果时序数据是围绕某个数值上下波动的，满足正态分布或者近似正态分布的，Nsigma或者箱线图都是不错的选择，Nsigma在工业领域使用的极其广泛。</li>
<li>如果时序数据存在多个集中值，比如说出行量在早晚是高峰，其他时间是低峰，则可以使用kde去估计出时序数据的概率密度分布，通过概率密度进行异常检测。</li>
<li>如果时序数据的变化是缓慢的，很少有突变，那么可以使用1阶差分+Nsigma的方式捕捉离群点和变点。</li>
<li>如果时序数据的变化理应是上下波动的，而不是一直上升（比如内存泄露导致的内存使用率稳定增长）或者一直下降，则可以使用Cusum累积和算法去捕捉这种情况下的异常。</li>
<li>EWMA基于平滑预测去判断异常，对于离群点和变点的检测都能很好的捕捉到。</li>
<li>基于机器学习的算法，通常对峰值离群点，多集中值数据的离群点有很好的检测。</li>
</ol>
<p>对于预测算法则有如下建议：</p>
<ol>
<li>对于无法转化成平稳序列的时序数据（即毫无规律或者受影响因素极多的数据），无法进行预测，无法进行预测，无法进行预测，或者说预测的结果没有任何可信度。（为什么要强调这一点，因为有些同学会认为预测算法什么数据都能预测，我想说那大家早就靠预测算法炒股发财了。。）</li>
<li>如果对预测长度没有很高的要求，但对出预测速度有要求，比如历史数据有1000个点，只需要快速预测未来20个点，那么回归类机器学习算法可能是你首先可以尝试的选择。</li>
<li>prophet算法在绝大部分预测场景里一般都能取得不错的效果，如果对于要预测的曲线非常了解，那么还可以配置很多prophet的参数让预测变得更准，唯一美中不足的是prophet的py包安装有些难度，且对于大数据量的预测计算速度没有回归类算法快速。</li>
<li>holt-winters，SARIMA是较为传统使用较为普遍的两类算法，对于使用者而言需要先确认要预测的时序数据是否含有季节性（不变的周期性）成分，并明确这个间隔（比如每个周六游戏在线人数都会固定的变多等）。两类算法的使用要求对时序数据的理解要多一些，比如是否有初始的趋势，比如对于自相关和偏自相关图阶数的选择等。目前借助auto-arima实现的SARIMA可以使用网格搜索最优参数，速度上可能会慢些。</li>
</ol>
<p>以上的算法选择只是自家经验之谈，有条件的话最好拿数据都试一遍，看看效果再做选择，毕竟实践才是检验真理的唯一标准。</p>
<h2 id="AIOps中时序数据算法介绍"><a href="#AIOps中时序数据算法介绍" class="headerlink" title="AIOps中时序数据算法介绍"></a>AIOps中时序数据算法介绍</h2><p>这一小节会对上面提到的算法做一个简单的介绍，为了避免数学公式对阅读造成的精神折磨，下面不会列出各类复杂的公式和数学定义，这里的介绍仅仅是为了让大家对这些算法有一个初步的感性认识。</p>
<h3 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h3><p>所谓异常点，就是在给定数据集内，有的数据表现与其他数据显著不同的点。异常检测就是在数据集中寻找异常点的过程。</p>
<h4 id="Nsigma"><a href="#Nsigma" class="headerlink" title="Nsigma"></a>Nsigma</h4><p>在自然界、人类社会及其他各个领域，许多测量值都会存在一种现象：中间密集，两边稀疏。比如正常人群的身高、体重、考试成绩、家庭收入等等，太突出的很少，太贫乏的也很少，大部分都在中间的水平波动。这种测量值的分布现象我们叫做正态分布，原因在于我们研究的对象群体总体来看具有类似的特征（比如都是正常人），这就是一个基准，但群体内部的个体存在差异，导致大家的特征并不会完全一致，所以测量值会在这个基准（均值）的上下波动，因此造成中间密集，两边稀疏的现象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/1004194-20201111152244755-76308780.png" alt="img"></p>
<p>在运维领域，某业务稳定的情况下，机器的资源使用率可能稳定在60%，偶尔会上下波动，这也属于正态分布。但是如果出现服务器故障，资源使用率可能就回飙升或者陡降，这种波动都会超过原有的正常范围，在数学上会通过标准差来刻画这种波动的幅度，当波动的幅度超过N倍的标准差时，我们就可以认为发生了故障，完全正态分布的数据，超过3倍标准差的波动的概率为0.27%，工业界一般会使用是否超过3倍作为异常检测的判断。而实际的运维数据很多都只是贴近正态分布，因此，N的选择需要根据实际需要来定。</p>
<p>很多时候，我们不仅想知道整个窗口的离群点，还想捕捉到在趋势中变化的点，这时可以使用1阶差分的方法，一阶差分是将时序数据的后一个值减去前一个值得到的差值，这种方法会关心相邻点之间的变化，不关心整体的变化，通过这样的处理，我们再对差分的值进行Nsigma异常检测，就可以捕捉到与临近点离群的异常值了。</p>
<h4 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h4><p>给出一组数据，比如公司所有成员的年龄，我们如何准确把握年龄的分布情况呢，可以通过最大值最小值得到年龄的跨度，可以通过中位数得到区间的中心的范围（为什么不用平均数呢？有个笑话，说我和马云的平均资产是几千亿，但我显然只和几千有关系，跟亿是万万沾不上边的），最好能用数轴表示每个成员的年龄，这样就可以一目了然了。</p>
<p>箱线图即是结合了以上想法的做法，它刻画了整体的数据分布，并通过三个分位数描绘了内部的差距情况（如下图）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220701114034983.png" alt="image-20220701114034983"></p>
<p>正常的状态下，运维数据呈现稳定&#x2F;规律的分布，当异常发生时，比如峰值，超过了之前刻画指标的箱线图标准，那么我们也可以认为发生了异常。上图的延伸线的长度类似于Nsigma的N，可以根据实际情况调整，已达到贴合人员判断的水平。</p>
<h4 id="EWMA"><a href="#EWMA" class="headerlink" title="EWMA"></a>EWMA</h4><p>EWMA（Exponential Weighted Moving Average），中文叫做指数加权移动平均，是基于移动平均上的一种算法，本身是一种预测算法，它根据时序数据过去的趋势，使用指数加权平均的方式（距离预测点越近的点权重越大，这也符合人们的通常看法：越远的数据对现在的影响越小，越近的数据影响越大）对现有的值进行预测，如果预测值与实际值差异过大，则认为发生了异常。</p>
<h4 id="KDE"><a href="#KDE" class="headerlink" title="KDE"></a>KDE</h4><p>KDE（Kernel Density Estimation），中文名叫核密度估计，它采用平滑的峰值函数(“核”)来拟合观察到的时序数据点，从而对真实的概率分布曲线进行模拟。下图是使用不同核函数进行拟合的结果。在很多情况下我们是不知道指标的分布情况的，比如直播访问量，可能在固定的几个时间段是比较高的（因为有不同的大主播在线），在其他时刻则相对较低。针对这种情况我们可以通过KDE去拟合真实的访问量在时段上的概率分布。当测量值在KDE图里是小概率的时候，我们就认为可能发生了异常。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220701135912883.png" alt="image-20220701135912883"></p>
<h4 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h4><p>DBSCAN，是机器学习聚类算法的一种，通过给定的半径，它会搜索每个点半径范围内的其他点，如果半径内没有其他的点，则认为此点距离其他的点过远，即为离群点。如下图所示，N点的半径内查找不到任何其他点，因此是离群点。红点半径内的其他点的数量较多，被认为是核心点，黄点半径内点数较少，被认为是边界点。</p>
<p>因为是基于密度计算范围，因此此算法可以接收高维数据，即也可以做多指标的异常检测。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220701141822441.png" alt="image-20220701141822441"></p>
<h4 id="孤立森林"><a href="#孤立森林" class="headerlink" title="孤立森林"></a>孤立森林</h4><p>孤立森林算法是由周志华老师在2008年提出的异常检测算法，原理可以这么来比喻：下面是一条公路，路边种了不少的树，每个点都是一棵树，下面需要随机的进行隔断，最终保证每棵树都被单独隔离出来。显而易见，红点标志的树因为距离其他树更远，所以更容易被孤立出来。通过这种划分的难度来判断哪些点更孤立，因为异常的点总是距离正常点更远，因此就更容易被划分出来，正经的说法就是：<strong>异常样本相较普通样本可以通过较少次数的随机特征分割被孤立出来</strong>。单次的随机隔断可能存在误差，但是综合通过多次的随机隔断结果，就能有比较高的可信度了。单次的隔断可以理解为一颗孤立所有点的树，多次的隔断结果就是“孤立森林”了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220701143637362.png" alt="image-20220701143637362"></p>
<h4 id="LOF"><a href="#LOF" class="headerlink" title="LOF"></a>LOF</h4><p>LOF（Local Outlier Factor），中文叫局部异常因子，类似DBSCAN，也是一种基于密度的算法，但是DBSCAN通常只能给出 0&#x2F;1 的判断（即：是不是异常点），不能量化每个数据点的异常程度。相比较而言，LOF算法是可以量化每个数据点的异常程度的，可以在某种程度理解为异常概率。</p>
<h4 id="OneClassSVM"><a href="#OneClassSVM" class="headerlink" title="OneClassSVM"></a>OneClassSVM</h4><p>OneClassSVM，一类SVM算法，属于支持向量机大家族的一种，它默认异常点的个数只占数据集的极少部分，因此它的目的就是找到一个超平面尽可能的将正常的点囊括进去，超平面以外的点认为是异常点。</p>
<h3 id="时序预测"><a href="#时序预测" class="headerlink" title="时序预测"></a>时序预测</h3><p>在进行数据分析和决策支撑时，总会希望能通过算法的时序预测结果作为数据支持。但可惜的是，现实中很多数据都无法做长期的预测，短期的预测有时效果也会不尽如人意，好用准确的预测是好的数据（可以转化为平稳性、长期大量的数据）、好的算法、好的分析人员共同作用的结果。</p>
<h4 id="Prophet"><a href="#Prophet" class="headerlink" title="Prophet"></a>Prophet</h4><p> FaceBook 开源的 Prophet最初是为了创建高质量的商业预测而开发的，这个库试图去解决目前许多业务时间序列常见的困难：人类行为的季节性因素；新产品和市场趋势的变动；特殊情况下的点。Prophet 官方声称，即使仅使用默认的参数设置，在许多情况下，Prophet 生成的预测与经验丰富的分析师提供的预测一样准确。在实际使用中prophet的表现也确实不俗，最重要的优点就是使用者友好，参数友好，使用友好。</p>
<p>prophet的原理本质上是基于时序分解的加性回归模型，首先按照趋势、周期、波动将时序数据分解，再分别通过对非周期性趋势、周期性、假期和特殊事件、残差的预测的结果求和来进行时序预测。</p>
<h4 id="SARIMA"><a href="#SARIMA" class="headerlink" title="SARIMA"></a>SARIMA</h4><p>SARIMA( Seasonal Autoregressive Integrated Moving Average ) 季节性差分自回归滑动平均模型。是常用的时间序列预测分析方法之一。该方法可以对任何周期的时间序列进行建模。因为 SARIMA 的部分参数需要根据自相关图和偏自相关图来进行选取。所以存在一定的使用成本，对使用者的能力提出了一定的要求。</p>
<p>它首先通过一系列方法将原始时序数据进行转换为平稳性数据，再通过自回归和移动平均进行预测，最后将结果加上非平稳的因素作为最终的预测值。</p>
<h3 id="回归算法"><a href="#回归算法" class="headerlink" title="回归算法"></a>回归算法</h3><p>通常，在我们的工作中，一般以快、准、好作为唯一的指导原则来构建模型。因此很多时候我们并不想花费大量的时间进行数据准备和数据变换，只想快速的进行预测，并期望得到不错的效果。这里，回归模型（包括普通的线性回归，也包括基于树的XGBoost回归）就提供了这样的解决方案。这种方法没有理论支持，但在实践中仍然非常有用，而且经常用于机器学习竞赛。接地气的说，就是我也不知道为什么它可以预测，并且预测的还算不错，但它就是可以做到。</p>
<p>当然，它通过移动时差的方式进行预测，所以他的预测步长在数据不多的时候非常有限，建议在数据充足的条件下使用它。</p>
<h4 id="Holt-Winters"><a href="#Holt-Winters" class="headerlink" title="Holt-Winters"></a>Holt-Winters</h4><p>Holt-Winters 模型，得名于发明人的姓氏 Charles Holt 和他的学生 Peter Winters，它的另一个名字叫做三次指数平滑法，本质上仍是移动平均的变种，不过增加了非常多的因素，包括序列、趋势、季节等。</p>
<p>如果要预测的时序数据没有季节性，那么是不太建议使用这种方法的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前，智能运维仍是运维领域发展的方向和目标，而时序数据的异常检测和预测作为多数AIOps场景的落地基石仍在其中占据着重要地位。千淘万漉虽辛苦，吹尽狂沙始到金。只有一步一步的思考和实践，才能将AIOps的落地做得更好。</p>
]]></content>
      <categories>
        <category>AIOps</category>
      </categories>
  </entry>
  <entry>
    <title>自动化日志解析/模板化的工具及平台介绍</title>
    <url>/2022/05/19/20220519_%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%9A%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90%E7%9A%84%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/20220519195652.png" alt="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/20220519195652.png"></p>
<p>日常工作查找资料的过程中发现了2019年的一篇论文，对日志解析的工具和使用情况进行了详细的统计和对比，对于了解日志解析&#x2F;模板提取领域有很大帮助，故此翻译论文如下。</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在许多软件系统的开发和维护过程中，日志是必不可少的。它们记录详细的运行时信息，使开发人员和支持工程师能够监控他们的系统并剖析异常行为和错误。然而，现代软件系统日益扩大的规模和复杂性使得日志量呈爆炸式增长。</p>
<p>在许多情况下，传统的手动日志检查方式变得不切实际。许多最近的研究以及工业工具都求助于强大的文本搜索和基于机器学习的分析解决方案。由于日志的非结构化性质，第一个关键步骤是将日志消息解析为结构化数据以供后续分析。</p>
<p>近年来，自动化日志解析在学术界和工业界都得到了广泛的研究，产生了一系列不同技术的日志解析器。为了更好地理解这些日志解析器的特点，在本文中，我们对自动化日志解析进行了全面的评估研究，并进一步发布了工具和基准，以便于重用。</p>
<p>更具体地说，我们在跨越分布式系统、超级计算机、操作系统、移动系统、服务器应用程序和独立软件的总共 16 个日志数据集上评估了 13 个日志解析器。我们报告了准确性、稳健性和效率方面的基准测试结果，这在生产中部署自动日志解析时具有实际重要性。</p>
<p>我们还分享了华为在工业应用中的成功案例和经验教训。我们相信我们的工作可以作为基础，并为未来自动日志解析的研究和部署提供有价值的指导。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><span id="more"></span>

<p>日志在软件系统的开发和维护中发挥着重要作用。将详细的系统运行时信息记录到日志中是一种常见的做法，目的是便于开发人员和支持工程师了解系统行为并跟踪可能出现的问题。 日志的丰富信息和普遍性支持各种系统管理和诊断任务，例如分析使用统计、确保应用程序安全、识别性能异常以及诊断错误和崩溃。</p>
<p>尽管日志中隐藏着巨大的价值，但如何有效地分析它们仍然是一个巨大的挑战。</p>
<p>首先，现代软件系统通常会生成大量日志（例如，商业云应用程序每小时大约产生千兆字节的数据 ）。即使是通过搜索和grep实用程序提供的帮助，手动检查大量的日志消息中的关键诊断信息也变得不切实际。其次，日志消息本质上是非结构化的，因为为了方便和灵活，开发人员通常使用自由文本记录系统事件 。这进一步增加了日志数据自动化分析的难度。</p>
<p>许多最近的研究（例如，工业解决方案（例如，Splunk 、ELK 、Logentries ）已经发展到提供强大的文本搜索和机器学习-基于分析能力。要启用此类日志分析，第一步也是最重要的一步是日志解析 [9]，这是一个将自由文本原始日志消息解析为结构化事件流的过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519191352803.png" alt="image-20220519191352803"></p>
<p>如图1所示的示例，每条日志消息都由日志语句打印，并记录特定的系统事件及其消息头和消息内容。消息头由日志框架确定，因此可以相对容易地提取，例如时间戳、详细级别（例如，ERROR&#x2F;INFO&#x2F;DEBUG）和组件。相比之下，开发人员编写的自由文本消息内容通常很难结构化，因为它是常量字符串和变量值的组合。</p>
<p>常量部分显示日志消息的事件模板，并且对于每个事件发生都保持不变。可变部分携带感兴趣的动态运行时信息（即参数），这些信息可能因不同的事件发生而异。</p>
<p>日志解析的目标是将每条日志消息转换为与关键参数相关联的特定事件模板（例如，“Received block &lt;*&gt; of size &lt;*&gt; from &#x2F;&lt;&gt;”）（例如，[“blk_-562725280853087685”） ，“67108864”，“10.251.91.84”]）。这里，“&lt;&gt;”表示每个参数的位置。</p>
<p>传统的日志解析方式依赖于手工制作的正则表达式或 grok 模式 来提取事件模板和关键参数。虽然很简单，但手动编写临时规则来解析大量日志确实是一种耗时且容易出错的痛苦（例如，我们的 Android 数据集中超过 76K 的模板）。特别是，现代软件系统中的日志代码通常会频繁更新（每月多达数千条日志语句 ），导致定期修改这些手工解析规则的成本不可避免。</p>
<p>为了减少日志解析中的手动工作，一些研究探索了直接从源代码中提取事件模板的静态分析技术。虽然在某些情况下这是一种可行的方法，但在实践中并不总是可以访问源代码（例如，在使用第三方组件时）。同时，为跨不同编程语言开发的软件系统构建这样一个静态分析工具需要付出不小的努力。</p>
<p>为了实现自动日志解析的目标，学术界和工业界都提出了许多数据驱动的方法，包括频繁模式挖掘（SLCT [20] 及其扩展 LogCluster ）、迭代分区（IPLoM ） ，层次聚类（LKE ），最长公共子序列计算（Spell），解析树（Drain）等。与手工规则和基于源代码的解析相比，这些方法能够学习来自日志数据的模式并自动生成常见的事件模板。</p>
<p>在我们之前的工作中，我们对四个具有代表性的日志解析器进行了评估研究，并朝着可重现的研究和自动化日志解析的开源工具迈出了第一步。这在一定程度上促进了一些工具的最新发展，例如 LenMa、LogMine、Spell、Drain和 MoLFI。更重要的是，自动日志解析最近成为一些趋势日志管理解决方案（例如，Logentries 和 Loggly）中的一个吸引人的卖点。</p>
<p>在本文中，我们对自动日志解析进行了更全面的研究，并进一步向研究人员和从业者发布了一整套工具和基准。 在现实中，公司通常因为机密问题而不愿公开他们的系统日志，导致现实世界的日志数据稀缺。 通过与我们的行业合作伙伴以及一些先驱研究人员的密切合作，我们收集了由 16 个不同系统生成的大量日志（总共超过 77GB），这些系统跨越分布式 系统、超级计算机、操作系统、移动系统、服务器应用程序和独立软件。 自这些日志首次发布以来，来自工业界和学术界的 150 多个组织都要求使用它们。</p>
<p>同时，缺乏公开可用的工具阻碍了自动日志解析的采用。因此，我们发布了一个易于使用的开源工具包，其中包含最近发布的 13 种日志解析方法。我们在 16 个不同的日志数据集上对它们进行了彻底的评估，并在准确性、稳健性和效率方面报告了结果。基准测试结果可以帮助用户更好地了解不同日志解析器的特性，并指导自动化日志解析在生产中的部署。 我们还分享了华为在工业应用中的成功案例和经验教训。 我们相信，工具和基准的可用性，以及本研究中分享的行业经验，将有利于未来的研究，并促进自动化日志解析在行业中的广泛采用。</p>
<p>本文其余部分安排如下。 第二节回顾了最先进的日志解析器。 第三部分报告了基准测试结果。我们在第四节分享我们的工业部署，并在第五节总结相关工作。最后，我们在第六节总结论文。</p>
<h1 id="日志解析"><a href="#日志解析" class="headerlink" title="日志解析"></a>日志解析</h1><p>在本节中，我们将介绍一些具有启发性的日志解析应用程序，回顾现有日志解析器的特征和技术，然后描述我们的工具实现。</p>
<h2 id="A-应用方向"><a href="#A-应用方向" class="headerlink" title="A.应用方向"></a>A.应用方向</h2><h3 id="日志解析-1"><a href="#日志解析-1" class="headerlink" title="日志解析"></a><strong>日志解析</strong></h3><p>日志解析通常作为下游日志分析任务的第一步。 将文本日志消息解析为结构化格式可实现高效的日志搜索、过滤、分组、计数和复杂挖掘。 为了说明，我们在此处提供了一个示例工业应用列表，这些示例已被研究人员和从业者广泛研究。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519191934078.png" alt="image-20220519191934078"></p>
<h3 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a>使用分析</h3><p>使用日志进行使用分析是软件开发和维护期间的常见任务。 典型示例包括用户行为分析（例如 Twitter）、API 分析、基于日志的指标计数（例如 Google Cloud ）和工作负载建模（例如 Microsoft）。这些应用程序通常需要结构化事件作为输入。</p>
<h3 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h3><p>如今，异常检测在系统监控中发挥着核心作用。日志记录了详细的执行信息，因此可作为检测异常系统行为的宝贵数据源。最近的一些工作研究了使用机器学习技术（例如，PCA 、不变挖掘和深度学习）进行异常检测。在这种情况下，日志解析是训练机器学习模型的必要数据预处理步骤。</p>
<h3 id="重复的问题识别"><a href="#重复的问题识别" class="headerlink" title="重复的问题识别"></a>重复的问题识别</h3><p>在实践中，系统问题（例如，磁盘错误，网络断开）经常重复出现或可能被不同的用户重复报告，导致许多重复问题。自动识别重复问题以减少开发人员和支持工程师的工作量至关重要。微软报告了一些关于这项任务的研究，其中需要结构化的事件数据。</p>
<h3 id="性能建模"><a href="#性能建模" class="headerlink" title="性能建模"></a>性能建模</h3><p>Facebook 最近报告了一个用例，将日志作为有价值的数据源应用于性能建模，可以快速验证潜在的性能改进。这种方法的先决条件是从日志中提取所有可能的事件模板。性能模型构建将事件序列作为输入。</p>
<h3 id="故障诊断"><a href="#故障诊断" class="headerlink" title="故障诊断"></a>故障诊断</h3><p>手动故障诊断是一项耗时且具有挑战性的任务，因为日志不仅数量庞大，而且非常冗长和混乱。最近的一些进展已经在基于机器学习技术的自动化根本原因分析方面取得了进展。同样，日志解析被视为先决条件。</p>
<h2 id="B-日志解析的特点"><a href="#B-日志解析的特点" class="headerlink" title="B.日志解析的特点"></a>B.日志解析的特点</h2><p>作为日志分析的一个重要步骤，日志解析的自动化方法得到了广泛的研究，产生了大量的日志解析器，从研究原型到工业解决方案。为了概述现有的日志解析器，我们总结了它们的关键特征。</p>
<h3 id="工业解决方案"><a href="#工业解决方案" class="headerlink" title="工业解决方案"></a>工业解决方案</h3><p>表一提供了一些工业日志分析和管理工具的总结。随着大数据的兴起，许多云提供商以及初创公司都为日志管理提供本地或软件即服务 (SaaS) 解决方案。它们支持强大的日志搜索、可视化和机器学习 (ML) 分析功能。为了说明，我们列出了市场上的 10 种代表性产品，包括成熟的产品（例如 Splunk）和新启动的产品（例如 Logz.io）。</p>
<p>作为一个关键组件，自动日志解析最近已成为某些产品的一个吸引人的卖点。然而，当前自动日志解析的解决方案是通过对常见日志类型的内置解析支持来实现的，例如 Apache 和 Nginx 日志。对于其他类型的日志，他们必须依靠用户使用正则表达式脚本、grok 模式或解析向导执行自定义解析。当前的工业解析解决方案需要深厚的领域知识，因此超出了本研究的范围。</p>
<h3 id="文献研究"><a href="#文献研究" class="headerlink" title="文献研究"></a>文献研究</h3><p>表二总结了文献中提出的 13 个具有代表性的日志解析器，它们是我们研究的主要主题。这些日志解析器都针对自动日志解析，但质量可能不同。在回顾了文献之后，我们列出了日志解析器的一些具有实际重要性的关键特性。</p>
<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p>不同的日志解析器可能采用不同的日志解析策略。 我们将它们分为7种类型的策略，包括频繁模式挖掘、聚类、迭代划分、最长公共子序列、解析树、进化算法和其他启发式。 我们将在第 II-C 节中介绍这些日志解析方法的更多细节。</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>根据日志解析的不同场景，日志解析器主要分为离线和在线两种模式。离线日志解析器是一种批处理，要求在解析之前所有日志数据都可用。相反，在线日志解析器以流的方式逐条处理日志消息，这在将日志收集为流时通常更实用。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>考虑到大量的日志，效率始终是实践中日志解析的主要关注点。在实时异常检测和性能监控等情况下，低效的日志解析器会极大地阻碍后续对延迟要求较低的日志分析任务。在表二中，当前工具的效率分为三个等级：高、中、低。</p>
<h4 id="覆盖范围"><a href="#覆盖范围" class="headerlink" title="覆盖范围"></a>覆盖范围</h4><p>覆盖率表示日志解析器成功解析所有输入日志消息的能力。如果是，则标记为“√”。 “×”表示日志解析器只能结构化部分日志。例如，SLCT可以通过应用频繁模式挖掘来提取频繁发生的事件模板，但无法精确处理稀有事件模板。高质量的日志解析器应该能够处理所有输入日志消息，因为忽略任何重要事件可能会错过异常检测和根本原因识别的机会。</p>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理是通过手动指定简单的正则表达式来删除一些常见变量值（例如 IP 地址和数字）的步骤。预处理步骤很简单，但需要一些额外的手动工作。如果在日志解析方法中明确指定了预处理步骤我们标记“√”，除此以外标记为“×”。</p>
<h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p>开源日志解析器可以让研究人员和从业者轻松重用和进一步改进现有的日志解析方法。这不仅可以有益于相关研究，还可以促进自动日志解析的广泛采用。但是，当前用于日志解析的开源工具仍然有限。如果现有的日志解析器是开源的我们标记“√”，除此以外标记为“×”。</p>
<h4 id="工业用途"><a href="#工业用途" class="headerlink" title="工业用途"></a>工业用途</h4><p>日志解析器具有更多的实用价值，如果它已部署在生产中以供工业使用，则应该更可靠。如果已报告日志解析器在工业环境中使用我们标记“√”，除此以外标记为“×”。</p>
<h2 id="C-日志解析的策略"><a href="#C-日志解析的策略" class="headerlink" title="C.日志解析的策略"></a>C.日志解析的策略</h2><h3 id="频繁模式挖掘"><a href="#频繁模式挖掘" class="headerlink" title="频繁模式挖掘"></a>频繁模式挖掘</h3><p>频繁模式是数据集中频繁出现的一组项目。同样，事件模板可以看作是日志中经常出现的一组常量标记。因此，频繁模式挖掘是自动化日志解析的一种直接方法。 示例包括 SLCT、LFA和 LogCluster。 所有三个日志解析器都是离线方法并遵循类似的解析过程：</p>
<p>1）通过多次遍历日志数据，</p>
<p>2）在每次遍历时构建频繁项集（例如，频繁项，频繁项位置对），</p>
<p>3）对日志消息进行分组分成几个集群</p>
<ol start="4">
<li>从每个集群中提取事件模板。</li>
</ol>
<p>据我们所知，SLCT 是第一个将频繁模式挖掘应用于日志解析的工作。此外，LFA考虑每个日志消息中的频繁项频率分布而不是整个日志数据来解析罕见的日志消息。LogCluster 是 SCLT 的扩展，并且可以对频繁项位置的变化具有鲁棒性。</p>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p>事件模板形成一组日志消息的自然模式。从这个角度来看，日志解析可以建模为日志消息的聚类问题。将聚类算法应用于日志解析的示例包括3种离线方法（即LKE、LogSig 和 LogMine）和 2 种在线方法（即 SHISO和 LenMa）.</p>
<p>具体来说，LKE 采用基于成对日志消息之间的加权编辑距离的层次聚类算法。LogSig 是一种基于消息签名的算法，用于将日志消息聚集到预定义数量的簇中。LogMine 可以通过分层集群的方式生成事件模板，将日志消息从下到上分组到集群中。 SHISO 和 LenMa 都是在线方法，它们以类似的流式方式解析日志。对于每个新出现的日志消息，解析器首先计算其与现有日志集群的代表性事件模板的相似性。如果匹配成功，则将日志消息添加到现有集群中，否则将创建新的日志集群。然后，相应的事件模板将相应更新。</p>
<h3 id="启发式"><a href="#启发式" class="headerlink" title="启发式"></a>启发式</h3><p>不同于一般的文本数据，日志消息有一些独特的特点。因此，一些工作（即 AEL、IPLoM、Drain）提出了基于启发式的日志解析方法。具体来说，AEL 通过比较常量标记和可变标记之间的出现将日志消息分成多个组。IPLoM 采用迭代分区策略，根据消息长度、频繁项位置和映射关系将日志消息划分为组。Drain 采用固定深度的树形结构来表示日志消息并有效地提取常用模板。这些启发式方法利用了日志的特性，在很多情况下都表现得很好。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>存在其他一些方法。例如，Spell利用最长公共子序列算法以流的方式解析日志。最近，Messaoudi 等人提出 MoLFI，它将日志解析建模为一个多目标优化问题，并使用进化算法解决它。</p>
<h2 id="D-策略实现"><a href="#D-策略实现" class="headerlink" title="D.策略实现"></a>D.策略实现</h2><p>尽管自动日志解析已经研究了几年，但它仍然不是工业界普遍接受的技术。这主要是由于缺乏可用于工业用途的公开可用工具。对于在机器学习技术方面的专业知识通常有限的运维工程师来说，实施自动化日志解析工具需要付出不小的努力。这可能会超过手动制作正则表达式的开销。</p>
<p>我们的工作旨在弥合学术界和工业界之间的差距，并促进采用自动化日志解析。我们已经实现了一个开源日志解析工具包，即 logparser，并发布了一个大型基准测试集。作为一个兼职项目，logparser 的实现耗时两年多，在 Python 中有11.7K LOC。目前，logparser 包含研究人员和从业者提出的总共 13 种日志解析方法。其中，五个日志解析器（即 SLCT、LogCluster、LenMa、Drain、MoLFI）是从现有研究工作中开源的。但是，它们以不同的编程语言实现，并具有不同的输入&#x2F;输出格式。示例和文件也缺失或不完整，给审判带来困难。</p>
<p>为了方便使用，我们为不同的日志解析方法定义了一个标准统一的输入&#x2F;输出接口，并将现有的工具进一步包装到一个单独的 Python 包中。Logparser 需要一个带有自由文本日志消息的原始日志文件作为输入，最后输出一个结构化日志文件和一个带有聚合事件计数的事件模板文件。输出可以很容易地输入到后续的日志挖掘任务中。我们的 logparser 工具包可以帮助工程师快速识别不同日志解析方法的优缺点，并评估它们在工业用例中的可能性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519193020521.png" alt="image-20220519193020521"></p>
<h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>在本节中，我们在16个基准数据集上评估了13个日志解析器，并报告了准确性、稳健性和效率方面的基准测试结果。 在生产中应用日志解析时，它们是三个令人感兴趣的关键品质。</p>
<p><strong>准确度</strong>衡量日志解析器区分常量部分和可变部分的能力。准确性是现有日志解析研究的主要焦点之一，因为不准确的日志解析器可能会极大地限制下游日志挖掘任务的有效性。</p>
<p><strong>鲁棒性</strong>，日志解析器的鲁棒性衡量其在不同大小或来自不同系统的日志数据集下的准确性的一致性。 一个健壮的日志解析器应该在不同的数据集上一致地执行，因此可以在通用的生产环境中使用。</p>
<p><strong>效率</strong>衡量日志解析器的处理速度。我们通过记录解析器解析特定数据集所花费的时间来评估效率。日志解析器消耗的时间越少，它提供的效率就越高。</p>
<h2 id="A-建立实验"><a href="#A-建立实验" class="headerlink" title="A.建立实验"></a>A.建立实验</h2><p><strong>数据集。</strong>由于机密问题，现实世界的日志数据目前公开稀缺，这阻碍了新的日志分析技术的研究和开发。在这项工作中，我们在我们的 loghub 数据存储库上发布了来自16个不同系统的大量日志集合，这些系统涵盖分布式系统、超级计算机、操作系统、移动系统、服务器应用程序和独立软件。表 III 提供了数据集的摘要。其中一些（例如，HDFS 、Hadoop、BGL）是先前研究发布的生产日志，而其他（例如，Spark、Zookeeper、HealthApp、Android）是从现实世界的系统中收集的我们的实验室。 Loghub 总共包含 4.4 亿条日志消息，大小为 77 GB。据我们所知，它是最大的日志数据集集合。在可能的情况下，不会以任何方式对日志进行清理、匿名或修改。它们可免费用于研究目的。在撰写本文时，我们的 loghub 数据集已被来自行业 (35%) 和学术界 (65%) 的 150 多个组织下载超过 1000 次。</p>
<p>在这项工作中，我们使用 loghub 数据集作为基准来评估所有现有的日志解析器。 loghub 数据集的庞大规模和多样性不仅可以衡量日志解析器的准确性，还可以测试它们的鲁棒性和效率。为了便于重现基准测试结果，我们从每个数据集中随机抽取 2000 条日志消息，并手动将事件模板标记为基本事实。具体而言，在表 III 中，“#Templates (2k sample)”表示日志样本中的事件模板数，而“#Templates(total)”表示基于规则的日志解析器生成的事件模板总数。</p>
<p><strong>准确度指标。</strong>为了量化自动日志解析的有效性，我们将解析精度 (PA) 指标定义为正确解析的日志消息与日志消息总数的比率。解析后，每条日志消息都有一个事件模板，该模板依次对应同一模板的一组消息。当且仅当其事件模板对应于与基本事实相同的日志消息组时，才认为日志消息已正确解析。例如，如果将日志序列 [E1, E2, E2] 解析为 [E1, E4, E5]，我们得到 PA&#x3D;1&#x2F;3，因为第 2 条和第 3 条消息没有组合在一起。与先前研究中使用的标准评估指标（例如精度、召回率和 F1-measure）相比，PA是一个更严格的指标。在PA中，部分匹配的事件被认为是不正确的。</p>
<h2 id="B-日志解析器的准确性"><a href="#B-日志解析器的准确性" class="headerlink" title="B.日志解析器的准确性"></a>B.日志解析器的准确性</h2><p>在这一部分中，我们评估日志解析器的准确性。我们发现一些日志解析器（例如，LKE）无法在合理的时间内（例如，甚至几天）处理原始数据集。因此，为了公平比较，准确性实验是在采样子集上进行的，每个子集包含 2,000 条日志消息。日志消息是从原始日志数据集中随机抽取的，但保留了关键属性，例如事件冗余和事件多样性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519193239948.png" alt="image-20220519193239948"></p>
<p>表 IV 展示了在 16 个日志数据集上评估的 13 个日志解析器的准确度结果。具体来说，每一行表示不同日志解析器在一个数据集上的解析精度，便于不同日志解析器之间的比较。每列代表一个日志解析器对不同数据集的解析精度，这有助于识别其在不同类型日志中的稳健性。特别是，我们用粗体标记了大于 0.9 的精度值，因为它们在实践中表示高精度。对于每个数据集，最佳准确度用星号“*”突出显示，并显示在“最佳”列中。</p>
<p>我们可以观察到，大多数数据集都被至少一个日志解析器准确（超过 90%）解析。总共13个日志解析器中有8个在至少两个日志数据集上达到了最佳精度。更重要的是，一些日志解析器可以 100% 准确地解析 HDFS 和 Apache 数据集。这是因为 HDFS 和 Apache 错误日志的事件模板相对简单，易于识别。然而，由于结构复杂、事件模板丰富（例如，Mac 日志中的 341 个模板），几种类型的日志（例如，OpenStack、Linux、Mac、HealthApp）仍然无法准确解析。因此，应该进一步改进以更好地解析那些复杂的日志数据。</p>
<p>为了衡量日志解析器的整体有效性，我们计算了每个日志解析器在不同数据集上的平均准确度，如表 IV 的最后一行所示。 我们可以观察到，平均而言，最准确的日志解析器是Drain，它在16个数据集中的9个数据集上达到了高精度。 其他排名靠前的日志解析器包括 IPLoM、AEL 和 Spell，它们在6个数据集上实现了高精度。相比之下，平均准确率最低的四个日志解析器是 LogSig、LFA、MoLFI 和 LKE。从结果可以简单得出结论，日志解析器应该充分利用日志消息的固有结构和特性来实现良好的解析精度，而不是直接应用聚类和频繁模式挖掘等标准算法。</p>
<h2 id="C-日志解析器的健壮性"><a href="#C-日志解析器的健壮性" class="headerlink" title="C.日志解析器的健壮性"></a>C.日志解析器的健壮性</h2><p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519193551418.png" alt="image-20220519193551418"></p>
<p>图2显示了一个箱线图，指示每个日志解析器在16个日志数据集中的准确度分布。对于每个框，从底部到顶部的水平线对应于最小值、25%、中值、75% 和最大精度值。菱形标记表示异常点，因为 LenMa 在 HealthApp 日志上的准确度仅为 0.174。图中从左到右，日志解析器按平均准确率升序排列，如表 IV 所示。</p>
<p>也就是说，平均而言，LogSig 的准确度最低，而 Drain 的准确度最高。一个好的日志解析器应该能够解析许多不同类型的日志以供一般使用。然而，我们可以观察到，尽管大多数日志解析器的最大准确度都超过了 0.9，但它们在不同的数据集上存在很大的差异。仍然没有对所有日志数据都表现良好的日志解析器。因此，我们建议用户先在自己的日志上尝试不同的日志解析器。</p>
<p>目前，Drain在所有13个正在研究的日志解析器中表现最好。它不仅平均达到最高的准确率，而且显示出最小的方差。</p>
<p>此外，我们评估了日志解析器在不同日志量上的鲁棒性。在本实验中，我们选择了六个日志解析器，即 MoLFI、Spell、LenMa、IPLoM、AEL 和 Drain。他们在四个以上的日志数据集上实现了高精度（超过 90%），如表 IV 所示。同时，MoLFI 是最近发布的日志解析器，其他五个日志解析器在图 2 中排名靠前。我们还选择了三个大型数据集，即 HDFS、BGL 和 Android。每个原始日志的容量超过 1GB，并且可以很容易地使用 groundtruth 模板进行准确度计算。HDFS 和 BGL 在之前的工作中也被用作基准数据集。对于每个日志数据集，我们将容量从 300 KB 更改为 1 GB，同时修复了在 2k 日志样本上微调的日志解析器的参数。</p>
<p>具体来说，300KB 大约是每个 2k 日志样本的大小。我们截断原始日志文件以获取其他卷的样本（例如 1GB）。图 3 显示了解析精度结果。请注意，图中有些行是不完整的，因为像 MoLFI 和 LenMa 这样的方法无法在合理的时间内（我们的实验中为 6 小时）完成解析。一个好的日志解析器应该对日志卷的这种变化具有鲁棒性。但是，我们可以看到在小日志样本上调整的参数不能很好地适应大日志数据。随着日志量的增加，所有六个性能最佳的日志解析器的准确性都有所下降或显示出明显的波动。除 IPLoM 外，日志解析器在 HDFS 数据上相对稳定，准确率达到 80% 以上。</p>
<p> Drain 和 AEL 在 BGL 数据上也显示出相对稳定的精度。然而，在Android数据上，所有解析器的准确性都有很大的下降，因为Android日志的事件模板数量相当多，解析起来也比较复杂。与其他日志解析器相比，Drain实现了相对稳定的精度，并且在更改日志量时显示了其鲁棒性。</p>
<h2 id="D-日志解析器的效率"><a href="#D-日志解析器的效率" class="headerlink" title="D.日志解析器的效率"></a>D.日志解析器的效率</h2><p>为了处理大规模的日志数据，效率是日志解析器需要考虑的一个重要方面。为了衡量日志解析器的效率，我们记录了它完成整个解析过程所需的运行时间。与之前实验的设置类似，我们在三个日志数据集上评估六个日志解析器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220519193759979.png" alt="image-20220519193759979"></p>
<p>结果如图 4 所示。很明显，解析时间随着所有三个数据集上日志大小的增加而增加。Drain 和 IPLoM 具有更好的效率，它与日志大小成线性关系。两种方法都可以在几十分钟内完成对 1GB 日志的解析。除了大型 BGL 数据外，AEL 也表现良好。这是因为 AEL 需要与 bin 中的每条日志消息进行比较，而 BGL 在数据集较大时具有较大的 bin 大小。其他日志解析器不能很好地适应日志量。尤其是 LenMa 和 MoLFI 甚至无法在 6 小时内完成解析 1GB 的 BGL 数据或 Android 数据。日志解析器的效率还取决于日志的类型。当日志数据简单且事件模板数量有限时，日志解析通常是一个高效的过程。例如，HDFS 日志仅包含 30 个事件模板，因此所有日志解析器可以在一个小时内处理 1GB 的数据。但是，对于具有大量事件模板（例如，Android）的日志，解析过程会变慢。</p>
<h1 id="工业部署"><a href="#工业部署" class="headerlink" title="工业部署"></a>工业部署</h1><p>在本节中，我们将分享我们在华为在生产环境中部署自动化日志解析的经验。 System X（匿名名称）是华为的热门产品之一。在整个产品生命周期中收集日志，从开发、测试、beta 测试到在线监控。它们被用作故障诊断、性能优化、用户分析、资源分配和其他一些提高产品质量的任务的主要数据源。当系统还处于小规模时，这些分析任务中的许多都可以手动执行。 然而，经过近年来的快速增长，如今的 System X 每天产生超过 TB 的日志数据。工程师手动检查日志以获取诊断信息变得不切实际，这不仅需要付出不小的努力，还需要对日志有深入的了解。在许多情况下，事件统计和相关性是帮助工程师做出明智决策的宝贵提示。</p>
<p>为了减少工程师的工作量，我们构建了一个平台（称为 LogKit）来自动化日志分析过程，包括日志搜索、基于规则的诊断以及事件统计和相关性的仪表板报告。该平台的一个关键特性是将日志解析为结构化数据。起初，日志解析是通过编写正则表达式来匹配感兴趣的事件以一种特别的方式完成的。但是，解析规则很快变得难以管理。首先，现有的解析规则不能涵盖所有类型的日志，因为要一个一个地编写解析规则是很耗时的。其次，System X 发展迅速，导致日志结构频繁变化。维护这样的日志解析规则库成为了新的痛点。因此，对自动日志解析的需求很高。</p>
<h2 id="成功的例子"><a href="#成功的例子" class="headerlink" title="成功的例子"></a>成功的例子</h2><p>通过与产品团队的密切合作，我们在生产环境中成功部署了自动化日志解析。 在第三节中描述的不同日志解析器的详细比较之后，我们选择Drain是因为它在准确性、鲁棒性和效率方面的优势。另外，利用System X的日志特性，我们从以下几个方面对Drain方式进行了优化。</p>
<p><strong>1）预处理。</strong> System X 的日志拥有上万个事件模板以及广泛的参数。正如我们在 [9] 中所做的那样，我们应用了一个简单而有效的预处理步骤来过滤常见参数，例如 IP、包名称、编号和文件路径。这大大简化了后续解析的问题。特别是，一些预处理脚本是从已经可用的原始解析规则库中提取的。</p>
<p><strong>2)   重复数据删除。</strong>许多日志消息仅包含常量字符串，内部没有参数（例如，“VM 已终止。”）。这些日志消息的重复出现会导致日志中出现大量重复消息。同时，预处理步骤也会产生大量重复的日志消息（例如，“Connected to <IP>”），其中常用参数已被删除。我们对这些重复的日志消息进行去重以减小数据大小，从而显着提高日志解析的效率。</p>
<p><strong>3)   分区。</strong>日志消息头包含两个字段：详细级别和组件。事实上，不同级别或组件的日志消息总是由不同的日志语句打印（例如，DEBUG 与 INFO）。因此，根据级别和组件信息将日志消息划分为不同的组是有益的。这自然将原始问题划分为独立的子问题。</p>
<p><strong>4）并行化。</strong>日志的分区不仅可以缩小事件模板的搜索空间，还可以实现并行化。特别是，我们使用 Spark 扩展 Drain，并自然地利用上述日志数据分区来实现快速并行化。到目前为止，我们已经在生产环境中成功运行Drain一年多，在 System X 中达到了 90% 以上的准确率。我们相信上述优化是通用的，也可以很容易地扩展到其他类似的系统。</p>
<h2 id="改进方向"><a href="#改进方向" class="headerlink" title="改进方向"></a>改进方向</h2><p>在 Drain 的工业部署过程中，我们观察到了一些需要进一步改进的方向。</p>
<p><strong>1) 状态识别。</strong>状态变量在日志分析中非常重要（例如，“DB connection ok”与“DB connection error”）。但是，当前的日志解析器无法将状态值与其他参数区分开来。</p>
<p><strong>2) 处理可变长度的日志消息。</strong>单个日志语句可能会产生长度可变的日志消息（例如，在打印列表时）。当前的日志解析器对长度敏感，无法处理这种情况，从而导致准确性下降。</p>
<p><strong>3) 自动参数调整。</strong>当前大多数日志解析器应用数据驱动的方法来提取事件模板，并且一些模型参数需要手动调整。需要开发一种用于自动参数调整的机制。我们呼吁进行研究以实现上述潜在改进，这将有助于更好地采用自动日志解析。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>略（此处主要说明了论文的人员贡献）</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>日志解析在系统维护中扮演着重要的角色，因为它是自动化日志分析的第一步。近年来，许多研究工作都致力于自动日志解析。但是，缺乏公开可用的日志解析工具和基准数据集。在本文中，我们总共实现了 13 种日志解析方法，并在来自不同类型软件系统的16个日志数据集上对它们进行了评估。我们已经开源了我们的工具包，并向研究人员和实践发布了基准数据集，以便于重用。此外，我们分享了在华为部署自动日志解析的成功案例和经验。我们希望我们的工作，连同发布的工具和基准，可以促进对日志分析的更多研究。</p>
<h1 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h1><p>本文翻译自论文<a href="https://arxiv.org/abs/1811.03509">《Tools and Benchmarks for Automated Log Parsing》</a>，作者：Jieming Zhu, Shilin He, Jinyang Liu, Pinjia He, Qi Xie, Zibin Zheng, [Michael R. Lyu]等。相关引用在翻译过程中取消了，引用部分和更多参考请查阅论文原文。</p>
<p>如有错漏和不通顺的地方或者感兴趣的地方欢迎在评论区提出。</p>
<p>如有侵权，还请联系我删除，本文目的旨在技术分享。</p>
]]></content>
      <categories>
        <category>AIOps</category>
      </categories>
      <tags>
        <tag>日志解析</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的socket编程</title>
    <url>/2022/06/02/20220602_Python%E4%B8%AD%E7%9A%84socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>网络编程是python应用的一块大领域，一直以来各种web应用框架（django, flask等）帮我们处理了底层的各种复杂的网络通信和数据处理，降低了开发人员的开发难度，但是另一方面也使得底层的东西被包裹在重重的框架下面无法看清和学习，因此本文从socket编程开始去一探网络编程的冰山一角。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>socket，翻译为插座，插口，编程上翻译为套接字，初看不太懂为什么叫这个名字，且将socket通信的双方（B&#x2F;S或者C&#x2F;S）理解为插座和插头的关系吧。</p>
<p>socket和socket API 被用于通过网络发送消息。它们提供了一种<a href="https://en.wikipedia.org/wiki/Inter-process_communication">进程间通信 (IPC)</a>形式。网络可以是计算机的逻辑的本地的网络（localhost），也可以是物理连接到外部网络的网络。一个明显的例子是您通过 ISP(Internet Service Provider，互联网服务提供商，就是电信、移动运营商等) 连接到的 Internet（目前的互联网）。</p>
<p>本次学习共有如下内容：</p>
<ul>
<li>建立一个简单的，可以互相通信的socket服务器和客户端</li>
<li>在上面的基础上建立可以同时处理<strong>多个连接的改进版本</strong></li>
<li>建立一个服务器-客户端应用程序，其功能类似于一个成熟的<strong>socket应用程序</strong>，具有自己的<strong>自定义标头和内容</strong></li>
</ul>
<span id="more"></span>

<p>网络和套接字编程是一个大的主题，python官网上已经有很详细的说明，但如果你对这块是个新手，那么估计和我一样阅读起来难度很大，本文就是为了解决这个问题，力求通过简单的示例和详细的说明去揭开这个大主题的一层面纱，希望你能有所收获~</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>socket已经有很长的历史了。它的使用<a href="https://en.wikipedia.org/wiki/Network_socket#History">起源于 1971 年的 ARPANET</a>，后来在 1983 年，发布成为伯克利软件 (BSD) 操作系统中的一个 API，称为 <a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets</a>。</p>
<p>当互联网在20世纪90年代随着万维网（World Wide Web）起飞时，对应的网络编程也随之风生水起。Web 服务器和浏览器（BS架构）并不是唯一利用新生网络和socket编程的应用程序，他们在各种类型和规模的客户端-服务器应用程序（CS架构）也得到了广泛使用。</p>
<p>一般来说，套接字应用程序用在客户端-服务器架构上（CS架构）的比较多，其中一侧充当服务器并等待来自客户端的连接。本文将专注于<a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Internet 套接字</a>的 API ，有时称为 Berkeley 或 BSD 套接字。除此之外还有<a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix 域套接字</a>，它只能用于在同一主机上的进程之间进行通信。</p>
<h1 id="Socket-API总览"><a href="#Socket-API总览" class="headerlink" title="Socket API总览"></a>Socket API总览</h1><p>Python 的<a href="https://docs.python.org/3/library/socket.html">socket 模块</a>为<a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets API</a>提供了一个接口。这也是本文中将学习使用的模块。</p>
<p>此模块中主要的API函数和方法如下：</p>
<ul>
<li><code>socket()</code></li>
<li><code>.bind()</code></li>
<li><code>.listen()</code></li>
<li><code>.accept()</code></li>
<li><code>.connect()</code></li>
<li><code>.connect_ex()</code></li>
<li><code>.send()</code></li>
<li><code>.recv()</code></li>
<li><code>.close()</code></li>
</ul>
<p>Python 提供了能够直接映射到操作系统调用的 API——socket（内置进标准库了），使用方便且接口调用保持一致。</p>
<p>除了socket库，Python 还有更高级的一些的类，他们封装了底层的socket函数。尽管本文没有介绍它，但您可以查看<a href="https://docs.python.org/3/library/socketserver.html">socketserver 模块</a>，这是一个网络服务器框架。还有许多模块可以实现更高级别的 Internet 协议，例如 HTTP 和 SMTP。有关概述，请参阅<a href="https://docs.python.org/3/library/internet.html">Internet 协议和支持</a>。</p>
<h1 id="TCP-Sockets"><a href="#TCP-Sockets" class="headerlink" title="TCP Sockets"></a>TCP Sockets</h1><p>您将使用<code>socket.socket()</code>来创建一个套接字对象，并将套接字类型指定为<code>socket.SOCK_STREAM</code>。当您这样做时，使用的默认协议是<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">传输控制协议 (TCP)</a>。这是一个很好的默认值，可能是正是您想要的。</p>
<p>为什么要使用 TCP（Transmission Control Protocol）？传输控制协议 (TCP)的优点是什么呢？</p>
<ul>
<li><strong>协议是可靠的：</strong>丢弃在网络中的数据包将会被发送方检测并重传。</li>
<li><strong>保证有序的数据传递：</strong>应用程序按照发送者写入的顺序读取数据。</li>
</ul>
<p>相比之下，使用<code>socket.SOCK_DGRAM</code>创建的<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">用户数据报协议 (UDP)</a>套接字是不可靠的，并且接收方读取的数据可能与发送方的写入顺序不一致。</p>
<p>为什么这两点很重要呢？网络是一个最大努力传输（best-effort）的系统。一般情况下，有很多突发情况是无法保证您的数据准确的到达目的地，或者给您的数据是准确完整有序的。</p>
<p>网络设备（例如路由器和交换机）的可用带宽有限，并且会受自身固有的系统限制——它们具有 CPU、内存、总线和接口数据包缓冲区，就像您的客户端和服务器一样。TCP 协议使您不必担心<a href="https://en.wikipedia.org/wiki/Packet_loss">数据包丢失</a>、无序数据到达以及在您通过网络进行通信时总是会发生的其他陷阱。</p>
<p>为了更好地理解这一点，请查看下图——TCP的套接字 API 调用过程和数据流的顺序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/sockets-tcp-flow.1da426797e37.jpg" alt="img"></p>
<p>左侧一列代表服务器。右侧一列代表客户端。</p>
<p>从左上角开始，注意服务器为设置监听状态而进行的 API 调用：</p>
<ul>
<li><code>socket()</code></li>
<li><code>bind()</code></li>
<li><code>listen()</code></li>
<li><code>accept()</code></li>
</ul>
<p>服务端首先要建立自己的socket对象，并对外监听。它侦听来自客户端的连接。当客户端连接时，服务端调用<code>.accept()</code>以接受或完成连接。</p>
<p>客户端调用<code>.connect()</code>建立与服务端的连接并启动三次握手。握手步骤很重要，因为它确保连接的每一端都可以在网络中访问，换句话说，客户端可以访问服务器，反之亦然。</p>
<p>流程的中间是往返部分，在客户端和服务器之间使用调用<code>.send()</code>和<code>.recv()</code>来交换数据。</p>
<p>在流程的底部，客户端和服务器关闭各自的套接字连接。</p>
<h1 id="Client-and-Server的第一次连接"><a href="#Client-and-Server的第一次连接" class="headerlink" title="Client and Server的第一次连接"></a>Client and Server的第一次连接</h1><p>现在，相信您已经了解了socket API的总体概况，并且对客户端和服务器如何通信有了初步印象。基于此我们可以创建第一个可以同学客户端和服务器了。我们将从简单的实现开始：1）建立客户端和服务端。2）服务端将返回任何从客户端收到的内容。</p>
<h2 id="Server部分"><a href="#Server部分" class="headerlink" title="Server部分"></a>Server部分</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo-server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;127.0.0.1&quot;</span>  <span class="comment"># 标准的环回接口地址(localhost)，用于同台主机同时作为客户端和服务端</span></span><br><span class="line">PORT = <span class="number">65432</span>  <span class="comment"># 端口监听 非特权端口需要端口号 &gt; 1023)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.bind((HOST, PORT))</span><br><span class="line">    s.listen()</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;客户端 <span class="subst">&#123;addr&#125;</span> 进行了访问&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = conn.recv(bufsize=<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            conn.sendall(data)</span><br></pre></td></tr></table></figure>

<p>现在不用担心对上述的代码有疑问，接下来我们一起逐句的分析每行代码的作用~</p>
<p>所以，上述的代码究竟做了什么事情呢？</p>
<p>首先，socket.socket（）方法创建了一个支持上下文管理器类型的套接字对象（socket object），因此可以用with语句使用它——这样就无需显示的调用s.close()方法了，因为已经在上下文里面执行了。</p>
<p>其次，socket对象接受两个参数：1）地址家族；2）socket的类型。socket.AF_INET表示是IPv4的网络地址。socket.SOCK_STREAM表示是TCP类型的socket（TCP是用于网络中传输消息的协议）。</p>
<p>而后，.bind（）方法用于将socket对象与指定的网络接口（IP地址）和端口号相关联。</p>
<h3 id="bind方法接受的参数"><a href="#bind方法接受的参数" class="headerlink" title="bind方法接受的参数"></a>bind方法接受的参数</h3><p>传递给.bind（）的参数取决于已实例化的socket的地址家族是什么。在此示例中，我们使用的是socket.af_inet（ipv4）。因此，bind接受一个双元素元组：（<strong>主机</strong>，<strong>端口</strong>）。</p>
<p><strong>主机</strong>可以是主机名，IP地址或空字符串。如果使用IP地址，则主机应为IPv4格式的地址字符串。IP地址127.0.0.1是环回接口的标准IPv4地址，因此只有同主机上的进程才能连接到服务器。如果你传递的是一个空字符串，服务器将接受所有可用的IPv4接口上的连接。</p>
<p><strong>端口</strong>代表TCP端口号，它可以接受客户端的连接。它的取值范围是1到65535的整数（0是被保留的）。如果端口号小于1024，则某些系统可能需要使用root账户。</p>
<p>下面是一段关于在.bind（）中使用主机参数的说明：</p>
<blockquote>
<p>“如果您在IPv4&#x2F;V6套接字地址的主机部分中使用主机名，则该程序可能会执行非确定性行为，因为Python使用的是从DNS解析器返回的第一个地址。根据DNS解析器以及主机的配置，套接字地址将以不同的方式分配到实际的IPv4&#x2F;V6地址中（即同一主机名可能对应不同的IP地址）。为了确定性行为，请在主机部分使用IP地址而不是主机名”</p>
</blockquote>
<p>所以，在使用主机名时，第一次运行应用程序时，您可能会获得地址10.1.2.3。下次，您将获得不同的地址，192.168.0.1。第三次，您可以获得172.16.7.8，依此类推。</p>
<h3 id="listen方法"><a href="#listen方法" class="headerlink" title="listen方法"></a>listen方法</h3><p>listen（）使服务端可以接受来自外部的连接。它使服务端成为一个时刻监听的服务。</p>
<p>该<a href="https://docs.python.org/3/library/socket.html#socket.socket.listen"><code>.listen()</code></a>方法有一个<code>backlog</code>参数。它指定系统在拒绝新连接之前将允许的未接受连接的数量。从 Python 3.5 起，它变成可选参数。如果未指定，<code>backlog</code>则选择系统默认值。</p>
<p>如果您的服务器同时接收到大量连接请求，通过设置待处理连接的队列的最大长度来增加该<code>backlog</code>的值可能会有所帮助。最大值取决于系统。例如，在 Linux 上，请参阅<a href="https://serverfault.com/questions/518862/will-increasing-net-core-somaxconn-make-a-difference/519152"><code>/proc/sys/net/core/somaxconn</code></a>.</p>
<h3 id="accept方法"><a href="#accept方法" class="headerlink" title="accept方法"></a>accept方法</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.accept"><code>.accept()</code></a>方法会<strong>阻塞执行</strong>并等待客户端传入连接。当客户端连接时，它返回一个表示连接的新套接字对象和一个保存客户端地址的元组。对于IPv4地址元组将包含<code>(host, port)</code> ，对于IPv6地址元组则包含<code>(host, port, flowinfo, scopeid)</code>。</p>
<p>必须记住的是，现在有一个来自<code>.accept()</code>方法的新的套接字对象（<strong>conn</strong>）。这很重要，因为它是将用于与客户端通信的套接字。它与服务端用来接受连接的监听套接字对象（<strong>s</strong>）不同。</p>
<p><code>accept()</code>提供客户端套接字对象<code>conn</code>后，将使用while死循环来循环对<code>conn.recv()</code>的<a href="https://realpython.com/python-sockets/#blocking-calls">阻塞</a>调用。这会读取客户端发送的任何数据并使用<code>conn.sendall()</code>发送回去。</p>
<p>如果<code>conn.recv()</code>返回一个空字节对象<code>b&#39;&#39;</code>，则表示客户端关闭连接并且循环终止。用于<code>conn</code>的<code>with</code>语句将在代码的末尾自动关闭套接字。</p>
<h2 id="Client部分"><a href="#Client部分" class="headerlink" title="Client部分"></a>Client部分</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo-client.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;127.0.0.1&quot;</span>  <span class="comment"># 服务端使用的主机地址或主机名</span></span><br><span class="line">PORT = <span class="number">65432</span>  <span class="comment"># 服务端使用的端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.connect((HOST, PORT))</span><br><span class="line">    s.sendall(<span class="string">b&quot;Hello, world&quot;</span>)</span><br><span class="line">    data = s.recv(bufsize=<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;接收数据： <span class="subst">&#123;data!r&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>与服务器相比，客户端非常简单。它创建一个套接字对象，用<code>.connect()</code>连接服务器并调用<code>s.sendall()</code>以发送消息。最后，它调用<code>s.recv()</code>读取服务器的回复，然后将其打印出来。</p>
<h2 id="启动Server和Client"><a href="#启动Server和Client" class="headerlink" title="启动Server和Client"></a>启动Server和Client</h2><p>打开终端或命令提示符，导航到包含脚本的目录，确保在路径上安装了 Python 3.6 或更高版本，然后运行服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bain pyscript]# python echo-server.py </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时此终端将出现挂起。那是因为服务器因为<code>.accept()</code>方法而被阻塞或挂起。它正在等待客户端连接。现在，打开另一个终端窗口或命令提示符并运行客户端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bain pyscript]# python echo-client.py </span><br><span class="line">接收数据： b&#x27;Hello, world&#x27;</span><br></pre></td></tr></table></figure>

<p>在服务器窗口中，会看到如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bain pyscript]# python echo-server.py </span><br><span class="line">客户端 (&#x27;127.0.0.1&#x27;, 41282) 进行了访问</span><br></pre></td></tr></table></figure>

<p>在上面的输出中，服务器打印了从<code>s.accept()</code>方法返回的<code>addr</code>元组. 这是客户端的 IP 地址和 TCP 端口号。端口号<code>64623</code>在不同的计算机上运行它时，可能会有所不同。</p>
<h2 id="查看套接字（Socket）状态"><a href="#查看套接字（Socket）状态" class="headerlink" title="查看套接字（Socket）状态"></a>查看套接字（Socket）状态</h2><p>要查看主机上套接字的当前状态，请使用<code>netstat</code> 它默认在 macOS、Linux 和 Windows 上可用。</p>
<p>这是启动服务器进行监听时 linux 的 netstat 输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bain pyscript]# netstat -an</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:65432         0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 192.168.10.101:22       192.168.10.100:10167    ESTABLISHED</span><br><span class="line">tcp        0     36 192.168.10.101:22       192.168.10.100:6420     ESTABLISHED</span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN     </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                          </span><br><span class="line">udp6       0      0 ::1:323                 :::*                               </span><br><span class="line">raw6       0      0 :::58                   :::*                    7          </span><br></pre></td></tr></table></figure>

<p>注意<code>Local Address</code>是<code>127.0.0.1.65432</code>。如果<code>echo-server.py</code>使用了<code>HOST = &quot;&quot;</code>而不是<code>HOST = &quot;127.0.0.1&quot;</code>，netstat 会显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bain pyscript]# netstat -an</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:65432           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 192.168.10.101:22       192.168.10.100:10167    ESTABLISHED</span><br><span class="line">tcp        0     36 192.168.10.101:22       192.168.10.100:6420     ESTABLISHED</span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN     </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                          </span><br><span class="line">udp6       0      0 ::1:323                 :::*                               </span><br><span class="line">raw6       0      0 :::58                   :::*                    7          </span><br></pre></td></tr></table></figure>

<p><code>Local Address</code>是 <code>0.0.0.0.65432</code>，这意味着支持IPv4地址族的所有可用主机接口都将用于接受传入连接。在此示例中，<code>socket.AF_INET</code>在对<code>socket()</code>的调用中使用了 (IPv4) 。您可以在<code>Proto</code>列中看到这一点：<code>tcp</code>。</p>
<p>需要注意的是<code>Proto</code>、<code>Local Address</code>和<code>(state)</code>列。在上面的输出里，netstat 命令显示服务器正在使用 IPv4 TCP 套接字 ( <code>tcp</code>)，且接受所有接口连接本机端口65432 （<code>0.0.0.0:65432</code>），且目前正处于监听状态 ( <code>LISTEN</code>)。</p>
<p>访问此文件以及其他有用信息的另一种方法是使用<code>lsof</code>（用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)）。它在 macOS 上默认可用，并且可以使用包管理器安装在 Linux 上（如果尚未安装）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@qianfeng01 pyscript]# lsof -i -n</span><br><span class="line">COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">...</span><br><span class="line">python  1556   root    3u  IPv4  23805      0t0  TCP *:65432 (LISTEN)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>lsof输出各列信息的意义如下：</p>
<ol>
<li>​	COMMAND：进程的名称</li>
<li>​	PID：进程标识符</li>
<li>​	PPID：父进程标识符（需要指定-R参数）</li>
<li>​	USER：进程所有者</li>
<li>​	PGID：进程所属组</li>
<li>​	FD：文件描述符，应用程序通过文件描述符识别该文件。</li>
</ol>
<p>当尝试连接到没有监听套接字的端口时，您会遇到以下常见错误（未启动服务端，仅启动客户端）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bain pyscript]# python echo-client.py </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;echo-client.py&quot;, line 9, in &lt;module&gt;</span><br><span class="line">    s.connect((HOST, PORT))</span><br><span class="line">ConnectionRefusedError: [Errno 111] Connection refused</span><br></pre></td></tr></table></figure>

<p>指定的端口号错误或服务器未运行会出现上面的错误。或者，连接路径中可能存在阻止连接的防火墙，这很容易忘记。还有可能还会看到错误<code>Connection timed out</code>。遇到这种情况需要服务端添加防火墙规则允许客户端连接到服务端的TCP 端口。</p>
<h1 id="CS通信过程"><a href="#CS通信过程" class="headerlink" title="CS通信过程"></a>CS通信过程</h1><p>现在我们来仔细研究下客户端和服务端到底是如何互相通信的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220606165635163.png" alt="image-20220606165635163"></p>
<p>使用<a href="https://en.wikipedia.org/wiki/Localhost">环回</a>接口（IPv4 地址<code>127.0.0.1</code>或 IPv6 地址<code>::1</code>）时，数据是永远不会离开主机或接触外部网络的。在上图中，环回接口是包含在主机内部的。这代表了环回接口的内部传输属性，并表明它的连接和数据传输对于主机来说都是在本地进行的。这就是为什么有时还会听到环回接口和 IP 地址<code>127.0.0.1</code>或<code>::1</code>被称为“localhost”的原因（指向的通信都是主机自身）。</p>
<p>为了保证安全性以及保证与外部网络的隔离，应用程序会使用环回接口（下图的lo0）与主机上运行的其他进程进行通信。因为它是内部的并且只能从主机内部访问，所以它不会暴露。</p>
<p>对于应用程序服务器使用的数据库，如果它不是其他服务器使用的数据库，它可能被配置为仅监听环回接口。如果是这种情况，网络上的其他主机将无法连接到它。</p>
<p>当您在应用程序中使用除<code>127.0.0.1</code>或<code>::1</code>之外的IP地址时，它可能绑定到连接到外部网络的以太网接口（下图的eth0）——这是与本机（localhost）之外其他主机进行通信的网关：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bainningking/pic_repo@main/img/image-20220606171028486.png" alt="image-20220606171028486"></p>
<p>当与外部主机进行通信时，请小心。外部的网络世界是残酷和危险的，在通信之前请一定要阅读相关安全说明（即使主机为IP地址而不是域名也同样要小心）</p>
<h1 id="如何处理多个连接"><a href="#如何处理多个连接" class="headerlink" title="如何处理多个连接"></a>如何处理多个连接</h1><p>上面的服务端有许多局限性，最大的一个是它只会服务一个客户端然后就退出了，客户端也是如此。客户端除此之外还有一个额外的问题，就是当客户端使用<code>s.recv()</code>时，它可能只返回一个字节，<code>b&#39;H&#39;</code>来自<code>b&#39;Hello, world&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo-client.py</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    data = s.recv(bufsize=<span class="number">1024</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面使用的<code>bufsize</code>参数表示<strong>每次</strong>接收的来自服务端的最大数据量（示例为1024字节）。</p>
<p><code>send()</code>方法同样也以这种方式运行。不同的是它的返回值是发送的字节数，并且发送的字节数可能小于数据传入的字节数。我们有必要对此进行检查并且在需要的情况下尽可能多次的调用send方法，以便将数据全部发出。</p>
<blockquote>
<p>“应用程序负责检查所有数据是否已发送；如果只传输了部分数据，则应用程序需要尝试传输剩余的数据。” <a href="https://docs.python.org/3/library/socket.html#socket.socket.send">（引用）</a></p>
</blockquote>
<p>在上面的示例中，我们通过使用<code>.sendall()</code>方法来避免检查操作：</p>
<blockquote>
<p>“与 send() 不同，此方法持续从字节发送数据，直到所有数据都已发送或发生错误。全部发送成功后返回<code>None</code>。” <a href="https://docs.python.org/3/library/socket.html#socket.socket.sendall">（引用）</a></p>
</blockquote>
<p>我们目前的问题如下：</p>
<ul>
<li>如何同时处理多个连接？</li>
<li>需要多次调用<code>.send()</code>，<code>.recv()</code>直到发送或接收所有数据。（而不是发一次就关闭连接了）</li>
</ul>
<p>针对上述的问题，有许多并发方法可以解决。一种流行的方法是使用<a href="https://docs.python.org/3/library/asyncio.html">异步 I&#x2F;O</a>。<code>asyncio</code>在 Python 3.4 中被引入标准库。一般而言传统的选择是使用线程。</p>
<p>并发方案很难做到正确的传输数据。实现的时候有许多微妙和细节的地方需要考虑和防范。因为只要有其中一个地方没考虑到，应用程序可能会以你想不到的方式崩溃。</p>
<p>这并不是要吓大家别去学习和使用并发编程的意思。如果我们的应用程序需要扩展，如果我们需要使用多个处理器或多个内核，并发就是必要的。在本文，我们将使用比线程更传统且更易于理解的东西。我们将使用系统调用的鼻祖方法：<a href="https://docs.python.org/3/library/selectors.html#selectors.BaseSelector.select"><code>.select()</code></a>.</p>
<p><code>.select()</code>方法允许我们检查多个套接字上的 I&#x2F;O 完成情况。因此，可以调用<code>.select()</code>查看哪些套接字已准备好读取&#x2F;或写入 I&#x2F;O。在Python里，我们将使用标准库中的<a href="https://docs.python.org/3/library/selectors.html">选择器</a>(selectors)模块，以便使用最有效的方式实现此功能，并且此模块的使用无需关注代码运行在何种操作系统上：</p>
<blockquote>
<p>“selectors模块建立在select原语模块的基础上，并且允许高级和高效的 I&#x2F;O 多路复用。我们鼓励用户使用这个模块，除非他们想要精确控制所使用的操作系统级原语。” <a href="https://docs.python.org/3/library/selectors.html">（引用）</a></p>
</blockquote>
<p>不过，如果使用了<code>.select()</code>方法，我们就不能并行的运行程序了。也就是说，确认是否使用并发编程前，我们需要考虑：1）应用程序在为请求提供服务时需要做什么；2）服务端需要支持的客户端数量。</p>
<p><a href="https://docs.python.org/3/library/asyncio.html"><code>asyncio</code></a>使用单线程协作多任务（即协程）和事件循环来管理任务。使用<code>.select()</code>，我们将编写自己的事件循环版本，简单且同步性强。当使用多线程做并发时，我们需要考虑GIL（全局解释器锁）的限制。</p>
<p>以上都是为了说明使用<code>.select()</code>可能是一个非常好的选择。不要觉得你必须使用<code>asyncio</code>、多线程或最新的异步库等。通常，在网络应用程序中，您的应用程序无论如何都是 I&#x2F;O 密集型的：它可能在本地网络上等待，或者等待网络另一端的端点，或者等待磁盘写入等等。</p>
<p>如果我们从客户端收到启动 CPU 密集型工作的请求，请查看<a href="https://docs.python.org/3/library/concurrent.futures.html">concurrent.futures</a>模块。它包含<a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor">ProcessPoolExecutor类</a>，它使用一个进程池来异步执行调用。</p>
<p>如果使用多进程，则操作系统能够安排 Python 代码在多个处理器或内核上并行运行，无需受限于 GIL。</p>
<h1 id="支持多个连接的Client和Server"><a href="#支持多个连接的Client和Server" class="headerlink" title="支持多个连接的Client和Server"></a>支持多个连接的Client和Server</h1><p>在接下来的两节里，我们将使用从<a href="https://docs.python.org/3/library/selectors.html">选择器</a>模块创建的<code>selector</code>对象创建能处理多个连接的服务器和客户端程序。</p>
<h2 id="多连接服务端"><a href="#多连接服务端" class="headerlink" title="多连接服务端"></a>多连接服务端</h2><p>我们先看下支持多连接的服务端程序该怎么写。第一步，先建立一个监听套接字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multiconn-server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">host, port = sys.argv[<span class="number">1</span>], <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">lsock.bind((host, port))</span><br><span class="line">lsock.listen()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Listening on <span class="subst">&#123;(host, port)&#125;</span>&quot;</span>)</span><br><span class="line">lsock.setblocking(<span class="literal">False</span>)</span><br><span class="line">sel.register(lsock, selectors.EVENT_READ, data=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>这个服务器和单连接服务器的最大区别是调用了<code>lsock.setblocking(False)</code>以非阻塞模式配置套接字。对此套接字的调用将不再阻塞。当它与<code>sel.select()</code>一起使用时，如下所示，您可以等待一个或多个套接字上的事件，然后在套接字准备好时读取和写入数据。</p>
<p><code>sel.register()</code>为感兴趣的<code>sel.select()</code>事件注册要被监视的套接字。对于监听套接字，需要读取事件： <code>selectors.EVENT_READ</code>。</p>
<p>要将想要的任意数据与套接字一起存储，需要使用<code>data</code>. 它将与<code>.select()</code>同时返回。我们利用<code>data</code>跟踪套接字上发送和接收的内容。</p>
<p>接下来是事件循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multiconn-server.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        events = sel.select(timeout=<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">            <span class="keyword">if</span> key.data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                accept_wrapper(key.fileobj)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                service_connection(key, mask)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Caught keyboard interrupt, exiting&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    sel.close()</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/3/library/selectors.html#selectors.BaseSelector.select"><code>sel.select(timeout=None)</code></a> 会一直阻塞，直到有套接字准备好进行 I&#x2F;O。它返回一个元组组成的列表，每个套接字对应一个元组。每个元组包含 一个<code>key</code>和 一个 <code>mask</code>。<code>key</code>是一个<a href="https://docs.python.org/3/library/selectors.html#selectors.SelectorKey">SelectorKey 。</a>的命名元组（namedtuple），它包括了一个fileobj属性：key.fileobj——这是一个套接字对象；还包括了一个准备好的操作的事件<a href="https://en.wikipedia.org/wiki/Mask_(computing)">掩码</a>。</p>
<p>events &#x3D; [((fileobj1, data1), mask1), (key2, mask2), …]</p>
<p>如果<code>key.data</code>为<code>None</code>，那么说明它来自监听套接字，我们需要接受连接。此时会调用<code>accept_wrapper()</code>函数来获取新的套接字对象并将其注册到选择器。函数内容在后面会展开。</p>
<p>如果<code>key.data</code>不为 <code>None</code>，那么说明它是一个已被接受的客户端套接字，此时需要为它提供服务。<code>service_connection()</code>会接收<code>key</code>and<code>mask</code>作为参数调用。</p>
<p>accept_wrapper()函数内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multiconn-server.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accept_wrapper</span>(<span class="params">sock</span>):</span><br><span class="line">    conn, addr = sock.accept()  <span class="comment"># Should be ready to read</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Accepted connection from <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>)</span><br><span class="line">    data = types.SimpleNamespace(addr=addr, inb=<span class="string">b&quot;&quot;</span>, outb=<span class="string">b&quot;&quot;</span>)</span><br><span class="line">    events = selectors.EVENT_READ | selectors.EVENT_WRITE</span><br><span class="line">    sel.register(conn, events, data=data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<p>因为监听套接字是为事件注册的<code>selectors.EVENT_READ</code>，所以它应该可以读取了。先调用<code>sock.accept()</code>然后调用<code>conn.setblocking(False)</code>将套接字置于<em>非阻塞</em>模式。</p>
<p>请记住，这是此阶段服务端的主要目标，因为我们不希望它<a href="https://realpython.com/python-sockets/#blocking-calls">阻塞</a>。如果它阻塞，则整个服务器将停止，直到它返回。这意味着即使服务器没有处于活动状态，其他套接字也会等待。我们不希望服务器处于可怕的“挂起”状态。</p>
<p>接下来，我们用<a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace"><code>SimpleNamespace</code></a>创建一个对象，用于包含所需的数据以及套接字. 因为我们想知道客户端连接何时准备好进行读写，所以这两个事件都使用<a href="https://realpython.com/python-bitwise-operators/#bitwise-or">按位 OR</a>运算符设置。</p>
<p>然后将<code>events</code>掩码、套接字和数据对象传递给<code>sel.register()</code>.</p>
<p>现在看一下客户端连接准备好后<code>service_connection()</code>是如何处理的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multiconn-server.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">service_connection</span>(<span class="params">key, mask</span>):</span><br><span class="line">    sock = key.fileobj</span><br><span class="line">    data = key.data</span><br><span class="line">    <span class="keyword">if</span> mask &amp; selectors.EVENT_READ:</span><br><span class="line">        recv_data = sock.recv(<span class="number">1024</span>)  <span class="comment"># Should be ready to read</span></span><br><span class="line">        <span class="keyword">if</span> recv_data:</span><br><span class="line">            data.outb += recv_data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Closing connection to <span class="subst">&#123;data.addr&#125;</span>&quot;</span>)</span><br><span class="line">            sel.unregister(sock)</span><br><span class="line">            sock.close()</span><br><span class="line">    <span class="keyword">if</span> mask &amp; selectors.EVENT_WRITE:</span><br><span class="line">        <span class="keyword">if</span> data.outb:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Echoing <span class="subst">&#123;data.outb!r&#125;</span> to <span class="subst">&#123;data.addr&#125;</span>&quot;</span>)</span><br><span class="line">            sent = sock.send(data.outb)  <span class="comment"># Should be ready to write</span></span><br><span class="line">            data.outb = data.outb[sent:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<p>这是简单多连接服务端的核心。<code>key</code>是<code>namedtuple</code>从<code>.select()</code>包含套接字对象（<code>fileobj</code>）和数据对象的返回值。<code>mask</code>包含准备好的事件。</p>
<p>如果套接字已准备好读取，则<code>mask &amp; selectors.EVENT_READ</code>计算结果为<code>True</code>，因此<code>sock.recv()</code>被调用。读取的任何数据都会附加到<code>data.outb</code>后面，以便以后发送。</p>
<p>注意<code>else</code>检查是否没有收到数据的块，如果没有收到数据，这意味着客户端已经关闭了他们的套接字，所以服务器也应该这样做。但是不要忘记在关闭之前调用<code>sel.unregister()</code>，如此套接字才能不再被<code>.select()</code>监控。</p>
<p>当套接字准备好写入时（对于一个健康的套接字来说应该总是如此），任何接收到的数据都会存储在<code>data.outb</code>中并使用<code>sock.send()</code>. 发送到客户端。然后从发送缓冲区中删除发送的字节。</p>
<p><code>.send()</code>方法返回发送的字节数。然后可以将此数字作为<a href="https://realpython.com/python-strings/#string-slicing">切片</a>用在<code>.outb</code>缓冲区上，以丢弃发送的字节。</p>
<h2 id="多连接客户端"><a href="#多连接客户端" class="headerlink" title="多连接客户端"></a>多连接客户端</h2><p>现在看看多连接客户端，<code>multiconn-client.py</code>. 它与服务端非常相似，但它不是监听连接，而是通过<code>start_connections()</code>的方式启动连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multiconn-client.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()</span><br><span class="line">messages = [<span class="string">b&quot;Message 1 from client.&quot;</span>, <span class="string">b&quot;Message 2 from client.&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_connections</span>(<span class="params">host, port, num_conns</span>):</span><br><span class="line">    server_addr = (host, port)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_conns):</span><br><span class="line">        connid = i + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Starting connection <span class="subst">&#123;connid&#125;</span> to <span class="subst">&#123;server_addr&#125;</span>&quot;</span>)</span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">        sock.connect_ex(server_addr)</span><br><span class="line">        events = selectors.EVENT_READ | selectors.EVENT_WRITE</span><br><span class="line">        data = types.SimpleNamespace(</span><br><span class="line">            connid=connid,</span><br><span class="line">            msg_total=<span class="built_in">sum</span>(<span class="built_in">len</span>(m) <span class="keyword">for</span> m <span class="keyword">in</span> messages),</span><br><span class="line">            recv_total=<span class="number">0</span>,</span><br><span class="line">            messages=messages.copy(),</span><br><span class="line">            outb=<span class="string">b&quot;&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">        sel.register(sock, events, data=data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<p><code>num_conns</code>从命令行读取，是要创建到服务端的连接数。同服务端一样，每个套接字都设置为非阻塞模式。</p>
<p>这里使用<a href="https://docs.python.org/3/library/socket.html#socket.socket.connect_ex"><code>.connect_ex()</code></a>而不是<code>.connect()</code>的原因是<code>.connect()</code>会立即引发<code>BlockingIOError</code>异常。而<code>.connect_ex()</code>方法会返回一个错误<em>指示符</em>, <code>errno.EINPROGRESS</code>，而不是引发会干扰正在进行的连接的异常。一旦连接完成，套接字就可以读写了，并由<code>.select()</code>.返回</p>
<p>设置套接字后，要使用套接字存储的数据是使用<code>SimpleNamespace</code>. 因为每个连接都会调用<code>socket.send()</code>和修改列表，所以客户端将发送到服务器的消息被<code>messages.copy()</code>复制使用。跟踪客户端需要发送、已发送和已接收的所有内容，包括消息中的总字节数，都存储在 object 中<code>data</code>。</p>
<p>查看服务器<code>service_connection()</code>对客户端版本所做的更改:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">def service_connection(key, mask):</span><br><span class="line">     sock = key.fileobj</span><br><span class="line">     data = key.data</span><br><span class="line">     if mask &amp; selectors.EVENT_READ:</span><br><span class="line">         recv_data = sock.recv(1024)  # Should be ready to read</span><br><span class="line">         if recv_data:</span><br><span class="line"><span class="deletion">-            data.outb += recv_data</span></span><br><span class="line"><span class="addition">+            print(f&quot;Received &#123;recv_data!r&#125; from connection &#123;data.connid&#125;&quot;)</span></span><br><span class="line"><span class="addition">+            data.recv_total += len(recv_data)</span></span><br><span class="line"><span class="deletion">-        else:</span></span><br><span class="line"><span class="deletion">-            print(f&quot;Closing connection &#123;data.connid&#125;&quot;)</span></span><br><span class="line"><span class="addition">+        if not recv_data or data.recv_total == data.msg_total:</span></span><br><span class="line"><span class="addition">+            print(f&quot;Closing connection &#123;data.connid&#125;&quot;)</span></span><br><span class="line">             sel.unregister(sock)</span><br><span class="line">             sock.close()</span><br><span class="line">     if mask &amp; selectors.EVENT_WRITE:</span><br><span class="line"><span class="addition">+        if not data.outb and data.messages:</span></span><br><span class="line"><span class="addition">+            data.outb = data.messages.pop(0)</span></span><br><span class="line">         if data.outb:</span><br><span class="line"><span class="deletion">-            print(f&quot;Echoing &#123;data.outb!r&#125; to &#123;data.addr&#125;&quot;)</span></span><br><span class="line"><span class="addition">+            print(f&quot;Sending &#123;data.outb!r&#125; to connection &#123;data.connid&#125;&quot;)</span></span><br><span class="line">             sent = sock.send(data.outb)  # Should be ready to write</span><br><span class="line">             data.outb = data.outb[sent:]</span><br></pre></td></tr></table></figure>



<p>客户端跟踪它从服务器接收到的字节数，以便它可以关闭它的连接端。当服务器检测到这一点时，它也会关闭它的连接端。</p>
<p>请注意，通过这样做，服务器依赖于表现良好的客户端：服务器希望客户端在完成发送消息后<em>关闭其连接端。</em>如果客户端没有关闭，服务器将保持连接打开。在实际应用程序中，您可能希望通过实施<a href="https://en.wikipedia.org/wiki/Timeout_(computing)">超时</a>来防止客户端连接在一定时间后不发送请求时累积，从而在服务器中防止这种情况。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
</search>
